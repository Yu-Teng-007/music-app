# ğŸ›¡ï¸ å®‰å…¨é˜²æŠ¤æŠ€æœ¯æ–‡æ¡£

**æŠ€æœ¯æ ˆ**: NestJS + JWT + CSRF + Rate Limiting  
**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-06-27

---

## ğŸ“‹ å®‰å…¨é˜²æŠ¤æ¦‚è§ˆ

å®‰å…¨é˜²æŠ¤ç³»ç»Ÿé‡‡ç”¨å¤šå±‚é˜²æŠ¤æ¶æ„ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€æˆæƒæ§åˆ¶ã€è¾“å…¥éªŒè¯ã€CSRFé˜²æŠ¤ã€XSSé˜²æŠ¤ã€SQLæ³¨å…¥é˜²æŠ¤ã€é€Ÿç‡é™åˆ¶ç­‰å¤šç§å®‰å…¨æœºåˆ¶ï¼Œç¡®ä¿åº”ç”¨çš„å…¨é¢å®‰å…¨ã€‚

### ğŸ—ï¸ å®‰å…¨æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç½‘ç»œå±‚å®‰å…¨    â”‚    â”‚   åº”ç”¨å±‚å®‰å…¨    â”‚    â”‚   æ•°æ®å±‚å®‰å…¨    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ HTTPS/TLS     â”‚â”€â”€â”€â–ºâ”‚ â€¢ JWTè®¤è¯       â”‚â”€â”€â”€â–ºâ”‚ â€¢ æ•°æ®åŠ å¯†      â”‚
â”‚ â€¢ é˜²ç«å¢™        â”‚    â”‚ â€¢ CSRFé˜²æŠ¤      â”‚    â”‚ â€¢ è®¿é—®æ§åˆ¶      â”‚
â”‚ â€¢ DDoSé˜²æŠ¤      â”‚    â”‚ â€¢ XSSé˜²æŠ¤       â”‚    â”‚ â€¢ å®¡è®¡æ—¥å¿—      â”‚
â”‚ â€¢ CDNå®‰å…¨       â”‚    â”‚ â€¢ è¾“å…¥éªŒè¯      â”‚    â”‚ â€¢ å¤‡ä»½åŠ å¯†      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç›‘æ§å‘Šè­¦      â”‚    â”‚   å¨èƒæ£€æµ‹      â”‚    â”‚   åˆè§„å®¡è®¡      â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ å®‰å…¨ç›‘æ§      â”‚    â”‚ â€¢ å¼‚å¸¸æ£€æµ‹      â”‚    â”‚ â€¢ å®‰å…¨æ‰«æ      â”‚
â”‚ â€¢ æ—¥å¿—åˆ†æ      â”‚    â”‚ â€¢ è¡Œä¸ºåˆ†æ      â”‚    â”‚ â€¢ æ¼æ´è¯„ä¼°      â”‚
â”‚ â€¢ å®æ—¶å‘Šè­¦      â”‚    â”‚ â€¢ é£é™©è¯„ä¼°      â”‚    â”‚ â€¢ åˆè§„æ£€æŸ¥      â”‚
â”‚ â€¢ äº‹ä»¶å“åº”      â”‚    â”‚ â€¢ è‡ªåŠ¨é˜»æ–­      â”‚    â”‚ â€¢ å®‰å…¨æŠ¥å‘Š      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” èº«ä»½è®¤è¯å’Œæˆæƒ

### JWTè®¤è¯å¢å¼º

```typescript
// src/auth/enhanced-jwt.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { ConfigService } from '@nestjs/config'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'
import * as crypto from 'crypto'

@Injectable()
export class EnhancedJwtService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    @InjectRedis() private readonly redis: Redis,
  ) {}

  /**
   * ç”Ÿæˆå®‰å…¨çš„JWTä»¤ç‰Œ
   */
  async generateSecureToken(user: any, deviceInfo: any): Promise<{
    accessToken: string
    refreshToken: string
    fingerprint: string
  }> {
    // ç”Ÿæˆè®¾å¤‡æŒ‡çº¹
    const fingerprint = this.generateDeviceFingerprint(deviceInfo)
    
    // ç”Ÿæˆå”¯ä¸€çš„JTI
    const jti = crypto.randomUUID()
    
    const payload = {
      sub: user.id,
      username: user.username,
      phone: user.phone,
      jti,
      fingerprint: fingerprint.substring(0, 16), // åªå­˜å‚¨éƒ¨åˆ†æŒ‡çº¹
      iat: Math.floor(Date.now() / 1000),
    }

    // ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    const accessToken = this.jwtService.sign(payload, {
      expiresIn: '15m',
      issuer: this.configService.get('jwt.issuer'),
      audience: this.configService.get('jwt.audience'),
    })

    // ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
    const refreshToken = this.jwtService.sign(
      { sub: user.id, jti, type: 'refresh' },
      {
        secret: this.configService.get('jwt.refreshSecret'),
        expiresIn: '7d',
      }
    )

    // å­˜å‚¨ä»¤ç‰Œä¿¡æ¯åˆ°Redis
    await this.storeTokenInfo(jti, {
      userId: user.id,
      fingerprint,
      deviceInfo,
      createdAt: new Date(),
      lastUsed: new Date(),
    })

    return { accessToken, refreshToken, fingerprint }
  }

  /**
   * éªŒè¯ä»¤ç‰Œå®‰å…¨æ€§
   */
  async verifySecureToken(token: string, deviceInfo: any): Promise<any> {
    try {
      const payload = this.jwtService.verify(token)
      
      // éªŒè¯è®¾å¤‡æŒ‡çº¹
      const currentFingerprint = this.generateDeviceFingerprint(deviceInfo)
      const storedInfo = await this.getTokenInfo(payload.jti)
      
      if (!storedInfo || storedInfo.fingerprint !== currentFingerprint) {
        throw new UnauthorizedException('Device fingerprint mismatch')
      }

      // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
      const isBlacklisted = await this.isTokenBlacklisted(payload.jti)
      if (isBlacklisted) {
        throw new UnauthorizedException('Token has been revoked')
      }

      // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
      await this.updateTokenLastUsed(payload.jti)

      return payload
    } catch (error) {
      throw new UnauthorizedException('Invalid token')
    }
  }

  /**
   * æ’¤é”€ä»¤ç‰Œ
   */
  async revokeToken(jti: string): Promise<void> {
    await this.redis.sadd('token_blacklist', jti)
    await this.redis.del(`token_info:${jti}`)
  }

  /**
   * æ’¤é”€ç”¨æˆ·æ‰€æœ‰ä»¤ç‰Œ
   */
  async revokeAllUserTokens(userId: string): Promise<void> {
    const pattern = `token_info:*`
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const info = await this.redis.get(key)
      if (info) {
        const tokenInfo = JSON.parse(info)
        if (tokenInfo.userId === userId) {
          const jti = key.split(':')[1]
          await this.revokeToken(jti)
        }
      }
    }
  }

  /**
   * ç”Ÿæˆè®¾å¤‡æŒ‡çº¹
   */
  private generateDeviceFingerprint(deviceInfo: any): string {
    const fingerprint = [
      deviceInfo.userAgent || '',
      deviceInfo.ip || '',
      deviceInfo.acceptLanguage || '',
      deviceInfo.timezone || '',
    ].join('|')

    return crypto.createHash('sha256').update(fingerprint).digest('hex')
  }

  /**
   * å­˜å‚¨ä»¤ç‰Œä¿¡æ¯
   */
  private async storeTokenInfo(jti: string, info: any): Promise<void> {
    await this.redis.setex(
      `token_info:${jti}`,
      7 * 24 * 60 * 60, // 7å¤©
      JSON.stringify(info)
    )
  }

  /**
   * è·å–ä»¤ç‰Œä¿¡æ¯
   */
  private async getTokenInfo(jti: string): Promise<any> {
    const info = await this.redis.get(`token_info:${jti}`)
    return info ? JSON.parse(info) : null
  }

  /**
   * æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
   */
  private async isTokenBlacklisted(jti: string): Promise<boolean> {
    return await this.redis.sismember('token_blacklist', jti)
  }

  /**
   * æ›´æ–°ä»¤ç‰Œæœ€åä½¿ç”¨æ—¶é—´
   */
  private async updateTokenLastUsed(jti: string): Promise<void> {
    const info = await this.getTokenInfo(jti)
    if (info) {
      info.lastUsed = new Date()
      await this.storeTokenInfo(jti, info)
    }
  }
}
```

### æƒé™æ§åˆ¶ç³»ç»Ÿ

```typescript
// src/auth/rbac/rbac.service.ts
import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { User } from '../../entities/user.entity'
import { Role } from '../../entities/role.entity'
import { Permission } from '../../entities/permission.entity'

export enum Action {
  CREATE = 'create',
  READ = 'read',
  UPDATE = 'update',
  DELETE = 'delete',
  MANAGE = 'manage',
}

export enum Resource {
  USER = 'user',
  SONG = 'song',
  PLAYLIST = 'playlist',
  COMMENT = 'comment',
  ADMIN = 'admin',
}

@Injectable()
export class RBACService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Role)
    private readonly roleRepository: Repository<Role>,
    @InjectRepository(Permission)
    private readonly permissionRepository: Repository<Permission>,
  ) {}

  /**
   * æ£€æŸ¥ç”¨æˆ·æƒé™
   */
  async checkPermission(
    userId: string,
    action: Action,
    resource: Resource,
    resourceId?: string
  ): Promise<boolean> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles', 'roles.permissions'],
    })

    if (!user) {
      return false
    }

    // æ£€æŸ¥ç”¨æˆ·è§’è‰²æƒé™
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        if (this.matchPermission(permission, action, resource)) {
          // æ£€æŸ¥èµ„æºçº§æƒé™
          if (resourceId && !this.checkResourceAccess(user, resource, resourceId)) {
            continue
          }
          return true
        }
      }
    }

    // æ£€æŸ¥èµ„æºæ‰€æœ‰æƒ
    if (resourceId) {
      return this.checkOwnership(userId, resource, resourceId)
    }

    return false
  }

  /**
   * è·å–ç”¨æˆ·æƒé™åˆ—è¡¨
   */
  async getUserPermissions(userId: string): Promise<string[]> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles', 'roles.permissions'],
    })

    if (!user) {
      return []
    }

    const permissions = new Set<string>()
    
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        permissions.add(`${permission.action}:${permission.resource}`)
      }
    }

    return Array.from(permissions)
  }

  /**
   * åˆ†é…è§’è‰²ç»™ç”¨æˆ·
   */
  async assignRole(userId: string, roleId: string): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles'],
    })

    const role = await this.roleRepository.findOne({
      where: { id: roleId },
    })

    if (user && role) {
      user.roles.push(role)
      await this.userRepository.save(user)
    }
  }

  /**
   * ç§»é™¤ç”¨æˆ·è§’è‰²
   */
  async removeRole(userId: string, roleId: string): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles'],
    })

    if (user) {
      user.roles = user.roles.filter(role => role.id !== roleId)
      await this.userRepository.save(user)
    }
  }

  /**
   * åˆ›å»ºè§’è‰²
   */
  async createRole(name: string, description: string, permissions: string[]): Promise<Role> {
    const role = this.roleRepository.create({
      name,
      description,
    })

    const savedRole = await this.roleRepository.save(role)

    // åˆ†é…æƒé™
    for (const permissionId of permissions) {
      const permission = await this.permissionRepository.findOne({
        where: { id: permissionId },
      })
      if (permission) {
        savedRole.permissions.push(permission)
      }
    }

    return this.roleRepository.save(savedRole)
  }

  /**
   * åŒ¹é…æƒé™
   */
  private matchPermission(
    permission: Permission,
    action: Action,
    resource: Resource
  ): boolean {
    // æ£€æŸ¥é€šé…ç¬¦æƒé™
    if (permission.action === Action.MANAGE || permission.action === action) {
      if (permission.resource === '*' || permission.resource === resource) {
        return true
      }
    }

    return false
  }

  /**
   * æ£€æŸ¥èµ„æºè®¿é—®æƒé™
   */
  private async checkResourceAccess(
    user: User,
    resource: Resource,
    resourceId: string
  ): Promise<boolean> {
    // æ ¹æ®èµ„æºç±»å‹æ£€æŸ¥ç‰¹å®šçš„è®¿é—®è§„åˆ™
    switch (resource) {
      case Resource.PLAYLIST:
        return this.checkPlaylistAccess(user.id, resourceId)
      case Resource.USER:
        return user.id === resourceId // ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„èµ„æº
      default:
        return true
    }
  }

  /**
   * æ£€æŸ¥æ‰€æœ‰æƒ
   */
  private async checkOwnership(
    userId: string,
    resource: Resource,
    resourceId: string
  ): Promise<boolean> {
    // å®ç°èµ„æºæ‰€æœ‰æƒæ£€æŸ¥é€»è¾‘
    // è¿™é‡Œåº”è¯¥æ ¹æ®å…·ä½“çš„ä¸šåŠ¡é€»è¾‘æ¥å®ç°
    return false
  }

  /**
   * æ£€æŸ¥æ­Œå•è®¿é—®æƒé™
   */
  private async checkPlaylistAccess(userId: string, playlistId: string): Promise<boolean> {
    // å®ç°æ­Œå•è®¿é—®æƒé™æ£€æŸ¥
    // ä¾‹å¦‚ï¼šå…¬å¼€æ­Œå•æ‰€æœ‰äººå¯è®¿é—®ï¼Œç§æœ‰æ­Œå•åªæœ‰æ‰€æœ‰è€…å¯è®¿é—®
    return true
  }
}
```

---

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯å’Œè¿‡æ»¤

### å…¨å±€éªŒè¯ç®¡é“

```typescript
// src/common/pipes/validation.pipe.ts
import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  BadRequestException,
} from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToClass } from 'class-transformer'
import * as DOMPurify from 'isomorphic-dompurify'

@Injectable()
export class GlobalValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return this.sanitizeInput(value)
    }

    // è½¬æ¢ä¸ºç±»å®ä¾‹
    const object = plainToClass(metatype, value)
    
    // éªŒè¯
    const errors = await validate(object, {
      whitelist: true, // åªä¿ç•™è£…é¥°å™¨æ ‡è®°çš„å±æ€§
      forbidNonWhitelisted: true, // ç¦æ­¢éç™½åå•å±æ€§
      transform: true, // è‡ªåŠ¨è½¬æ¢ç±»å‹
    })

    if (errors.length > 0) {
      const errorMessages = this.formatErrors(errors)
      throw new BadRequestException({
        message: 'è¾“å…¥éªŒè¯å¤±è´¥',
        errors: errorMessages,
      })
    }

    return this.sanitizeInput(object)
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }

  private formatErrors(errors: any[]): string[] {
    return errors.map(error => {
      const constraints = error.constraints
      return Object.values(constraints).join(', ')
    })
  }

  /**
   * è¾“å…¥æ¸…ç†
   */
  private sanitizeInput(input: any): any {
    if (typeof input === 'string') {
      // XSSé˜²æŠ¤ï¼šæ¸…ç†HTMLæ ‡ç­¾
      return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] })
    }

    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeInput(item))
    }

    if (input && typeof input === 'object') {
      const sanitized = {}
      for (const [key, value] of Object.entries(input)) {
        sanitized[this.sanitizeInput(key)] = this.sanitizeInput(value)
      }
      return sanitized
    }

    return input
  }
}
```

### SQLæ³¨å…¥é˜²æŠ¤

```typescript
// src/common/guards/sql-injection.guard.ts
import { Injectable, CanActivate, ExecutionContext, BadRequestException } from '@nestjs/common'

@Injectable()
export class SqlInjectionGuard implements CanActivate {
  private readonly sqlInjectionPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/gi,
    /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
    /(--|\/\*|\*\/|;)/g,
    /(\b(CHAR|NCHAR|VARCHAR|NVARCHAR)\s*\(\s*\d+\s*\))/gi,
    /(\b(CAST|CONVERT|SUBSTRING|ASCII|CHAR_LENGTH)\s*\()/gi,
  ]

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest()
    
    // æ£€æŸ¥æŸ¥è¯¢å‚æ•°
    this.validateInput(request.query, 'query parameters')
    
    // æ£€æŸ¥è¯·æ±‚ä½“
    this.validateInput(request.body, 'request body')
    
    // æ£€æŸ¥è·¯å¾„å‚æ•°
    this.validateInput(request.params, 'path parameters')

    return true
  }

  private validateInput(input: any, source: string): void {
    if (!input) return

    const inputString = JSON.stringify(input)
    
    for (const pattern of this.sqlInjectionPatterns) {
      if (pattern.test(inputString)) {
        throw new BadRequestException(
          `Potential SQL injection detected in ${source}`
        )
      }
    }
  }
}
```

---

## ğŸš« CSRFé˜²æŠ¤å¢å¼º

### åŠ¨æ€CSRFä»¤ç‰Œ

```typescript
// src/security/csrf/dynamic-csrf.service.ts
import { Injectable } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'
import * as crypto from 'crypto'

@Injectable()
export class DynamicCSRFService {
  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * ç”ŸæˆCSRFä»¤ç‰Œ
   */
  async generateToken(sessionId: string, action?: string): Promise<string> {
    const timestamp = Date.now()
    const random = crypto.randomBytes(16).toString('hex')
    const actionSuffix = action ? `:${action}` : ''
    
    // åˆ›å»ºä»¤ç‰Œæ•°æ®
    const tokenData = {
      sessionId,
      timestamp,
      random,
      action,
    }

    // ç”Ÿæˆä»¤ç‰Œ
    const token = this.createToken(tokenData)
    
    // å­˜å‚¨ä»¤ç‰Œä¿¡æ¯
    await this.redis.setex(
      `csrf:${token}`,
      3600, // 1å°æ—¶è¿‡æœŸ
      JSON.stringify(tokenData)
    )

    return token
  }

  /**
   * éªŒè¯CSRFä»¤ç‰Œ
   */
  async validateToken(
    token: string,
    sessionId: string,
    action?: string
  ): Promise<boolean> {
    try {
      // ä»Redisè·å–ä»¤ç‰Œæ•°æ®
      const storedData = await this.redis.get(`csrf:${token}`)
      if (!storedData) {
        return false
      }

      const tokenData = JSON.parse(storedData)

      // éªŒè¯ä¼šè¯ID
      if (tokenData.sessionId !== sessionId) {
        return false
      }

      // éªŒè¯åŠ¨ä½œï¼ˆå¦‚æœæŒ‡å®šï¼‰
      if (action && tokenData.action && tokenData.action !== action) {
        return false
      }

      // éªŒè¯æ—¶é—´æˆ³ï¼ˆé˜²æ­¢é‡æ”¾æ”»å‡»ï¼‰
      const now = Date.now()
      const tokenAge = now - tokenData.timestamp
      if (tokenAge > 3600000) { // 1å°æ—¶
        return false
      }

      // éªŒè¯ä»¤ç‰Œå®Œæ•´æ€§
      const expectedToken = this.createToken(tokenData)
      if (token !== expectedToken) {
        return false
      }

      // ä¸€æ¬¡æ€§ä½¿ç”¨ï¼šéªŒè¯ååˆ é™¤ä»¤ç‰Œ
      await this.redis.del(`csrf:${token}`)

      return true
    } catch (error) {
      return false
    }
  }

  /**
   * åˆ›å»ºä»¤ç‰Œ
   */
  private createToken(tokenData: any): string {
    const payload = `${tokenData.sessionId}:${tokenData.timestamp}:${tokenData.random}`
    const signature = crypto
      .createHmac('sha256', process.env.CSRF_SECRET || 'default-secret')
      .update(payload)
      .digest('hex')

    return Buffer.from(`${payload}:${signature}`).toString('base64')
  }

  /**
   * æ¸…ç†è¿‡æœŸä»¤ç‰Œ
   */
  async cleanupExpiredTokens(): Promise<void> {
    const pattern = 'csrf:*'
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const ttl = await this.redis.ttl(key)
      if (ttl <= 0) {
        await this.redis.del(key)
      }
    }
  }
}
```

### CSRFå®ˆå«

```typescript
// src/security/csrf/csrf.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { DynamicCSRFService } from './dynamic-csrf.service'

@Injectable()
export class CSRFGuard implements CanActivate {
  constructor(
    private readonly csrfService: DynamicCSRFService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // æ£€æŸ¥æ˜¯å¦è·³è¿‡CSRFéªŒè¯
    const skipCSRF = this.reflector.get<boolean>('skipCSRF', context.getHandler())
    if (skipCSRF) {
      return true
    }

    const request = context.switchToHttp().getRequest()
    const method = request.method.toLowerCase()

    // åªå¯¹çŠ¶æ€æ”¹å˜çš„è¯·æ±‚è¿›è¡ŒCSRFéªŒè¯
    if (!['post', 'put', 'patch', 'delete'].includes(method)) {
      return true
    }

    // è·å–CSRFä»¤ç‰Œ
    const token = this.extractCSRFToken(request)
    if (!token) {
      throw new ForbiddenException('CSRF token missing')
    }

    // è·å–ä¼šè¯ID
    const sessionId = this.extractSessionId(request)
    if (!sessionId) {
      throw new ForbiddenException('Session ID missing')
    }

    // è·å–åŠ¨ä½œï¼ˆå¯é€‰ï¼‰
    const action = this.extractAction(request)

    // éªŒè¯CSRFä»¤ç‰Œ
    const isValid = await this.csrfService.validateToken(token, sessionId, action)
    if (!isValid) {
      throw new ForbiddenException('Invalid CSRF token')
    }

    return true
  }

  private extractCSRFToken(request: any): string | null {
    // ä»å¤šä¸ªä½ç½®å°è¯•è·å–CSRFä»¤ç‰Œ
    return (
      request.headers['x-csrf-token'] ||
      request.headers['x-xsrf-token'] ||
      request.body?._csrf ||
      request.query?._csrf ||
      null
    )
  }

  private extractSessionId(request: any): string | null {
    // ä»JWTä»¤ç‰Œæˆ–ä¼šè¯ä¸­è·å–ä¼šè¯ID
    return request.user?.jti || request.sessionID || null
  }

  private extractAction(request: any): string | null {
    // ä»è¯·æ±‚ä¸­æå–åŠ¨ä½œä¿¡æ¯
    const path = request.route?.path || request.url
    const method = request.method.toLowerCase()
    return `${method}:${path}`
  }
}
```

---

## ğŸš¦ é€Ÿç‡é™åˆ¶å’Œé˜²æŠ¤

### æ™ºèƒ½é€Ÿç‡é™åˆ¶

```typescript
// src/security/rate-limit/smart-rate-limit.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'

interface RateLimitConfig {
  windowMs: number // æ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰
  maxRequests: number // æœ€å¤§è¯·æ±‚æ•°
  skipSuccessfulRequests?: boolean // æ˜¯å¦è·³è¿‡æˆåŠŸè¯·æ±‚
  skipFailedRequests?: boolean // æ˜¯å¦è·³è¿‡å¤±è´¥è¯·æ±‚
  keyGenerator?: (req: any) => string // è‡ªå®šä¹‰é”®ç”Ÿæˆå™¨
}

interface RateLimitResult {
  allowed: boolean
  remaining: number
  resetTime: number
  retryAfter?: number
}

@Injectable()
export class SmartRateLimitService {
  private readonly logger = new Logger(SmartRateLimitService.name)

  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * æ£€æŸ¥é€Ÿç‡é™åˆ¶
   */
  async checkRateLimit(
    key: string,
    config: RateLimitConfig
  ): Promise<RateLimitResult> {
    const now = Date.now()
    const windowStart = now - config.windowMs
    
    // ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•
    const pipeline = this.redis.pipeline()
    
    // ç§»é™¤è¿‡æœŸçš„è¯·æ±‚è®°å½•
    pipeline.zremrangebyscore(key, 0, windowStart)
    
    // æ·»åŠ å½“å‰è¯·æ±‚
    pipeline.zadd(key, now, `${now}-${Math.random()}`)
    
    // è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
    pipeline.zcard(key)
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    pipeline.expire(key, Math.ceil(config.windowMs / 1000))
    
    const results = await pipeline.exec()
    const requestCount = results[2][1] as number

    const remaining = Math.max(0, config.maxRequests - requestCount)
    const resetTime = now + config.windowMs

    if (requestCount > config.maxRequests) {
      const retryAfter = Math.ceil(config.windowMs / 1000)
      
      this.logger.warn(`Rate limit exceeded for key: ${key}`, {
        requestCount,
        maxRequests: config.maxRequests,
        windowMs: config.windowMs,
      })

      return {
        allowed: false,
        remaining: 0,
        resetTime,
        retryAfter,
      }
    }

    return {
      allowed: true,
      remaining,
      resetTime,
    }
  }

  /**
   * è‡ªé€‚åº”é€Ÿç‡é™åˆ¶
   */
  async adaptiveRateLimit(
    key: string,
    baseConfig: RateLimitConfig,
    errorRate: number
  ): Promise<RateLimitResult> {
    // æ ¹æ®é”™è¯¯ç‡è°ƒæ•´é™åˆ¶
    let adjustedConfig = { ...baseConfig }
    
    if (errorRate > 0.1) { // é”™è¯¯ç‡è¶…è¿‡10%
      adjustedConfig.maxRequests = Math.floor(baseConfig.maxRequests * 0.5)
    } else if (errorRate > 0.05) { // é”™è¯¯ç‡è¶…è¿‡5%
      adjustedConfig.maxRequests = Math.floor(baseConfig.maxRequests * 0.7)
    }

    return this.checkRateLimit(key, adjustedConfig)
  }

  /**
   * åˆ†å¸ƒå¼é€Ÿç‡é™åˆ¶
   */
  async distributedRateLimit(
    key: string,
    config: RateLimitConfig,
    nodeId: string
  ): Promise<RateLimitResult> {
    // ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºç‹¬ç«‹çš„è®¡æ•°å™¨
    const nodeKey = `${key}:${nodeId}`
    
    // è·å–æ‰€æœ‰èŠ‚ç‚¹çš„è¯·æ±‚æ•°
    const pattern = `${key}:*`
    const keys = await this.redis.keys(pattern)
    
    let totalRequests = 0
    for (const nodeKey of keys) {
      const count = await this.redis.zcard(nodeKey)
      totalRequests += count
    }

    // è®¡ç®—å½“å‰èŠ‚ç‚¹çš„é…é¢
    const nodeQuota = Math.ceil(config.maxRequests / keys.length)
    const nodeConfig = { ...config, maxRequests: nodeQuota }

    return this.checkRateLimit(nodeKey, nodeConfig)
  }

  /**
   * è·å–é€Ÿç‡é™åˆ¶ç»Ÿè®¡
   */
  async getRateLimitStats(keyPattern: string): Promise<any> {
    const keys = await this.redis.keys(keyPattern)
    const stats = []

    for (const key of keys) {
      const count = await this.redis.zcard(key)
      const ttl = await this.redis.ttl(key)
      
      stats.push({
        key,
        requestCount: count,
        ttl,
      })
    }

    return stats
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„é€Ÿç‡é™åˆ¶æ•°æ®
   */
  async cleanupExpiredData(): Promise<void> {
    const pattern = 'rate_limit:*'
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const ttl = await this.redis.ttl(key)
      if (ttl <= 0) {
        await this.redis.del(key)
      }
    }
  }
}
```

### é€Ÿç‡é™åˆ¶å®ˆå«

```typescript
// src/security/rate-limit/rate-limit.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { SmartRateLimitService } from './smart-rate-limit.service'

interface RateLimitOptions {
  windowMs?: number
  maxRequests?: number
  keyGenerator?: (req: any) => string
  skipIf?: (req: any) => boolean
  message?: string
}

@Injectable()
export class RateLimitGuard implements CanActivate {
  constructor(
    private readonly rateLimitService: SmartRateLimitService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()
    const response = context.switchToHttp().getResponse()

    // è·å–é€Ÿç‡é™åˆ¶é…ç½®
    const options = this.reflector.get<RateLimitOptions>(
      'rateLimit',
      context.getHandler(),
    ) || this.getDefaultOptions()

    // æ£€æŸ¥æ˜¯å¦è·³è¿‡
    if (options.skipIf && options.skipIf(request)) {
      return true
    }

    // ç”Ÿæˆé™åˆ¶é”®
    const key = this.generateKey(request, options.keyGenerator)

    // æ£€æŸ¥é€Ÿç‡é™åˆ¶
    const result = await this.rateLimitService.checkRateLimit(key, {
      windowMs: options.windowMs || 60000, // é»˜è®¤1åˆ†é’Ÿ
      maxRequests: options.maxRequests || 100, // é»˜è®¤100æ¬¡
    })

    // è®¾ç½®å“åº”å¤´
    response.setHeader('X-RateLimit-Limit', options.maxRequests)
    response.setHeader('X-RateLimit-Remaining', result.remaining)
    response.setHeader('X-RateLimit-Reset', new Date(result.resetTime).toISOString())

    if (!result.allowed) {
      response.setHeader('Retry-After', result.retryAfter)

      throw new HttpException(
        {
          statusCode: HttpStatus.TOO_MANY_REQUESTS,
          message: options.message || 'Too many requests',
          retryAfter: result.retryAfter,
        },
        HttpStatus.TOO_MANY_REQUESTS,
      )
    }

    return true
  }

  private generateKey(request: any, keyGenerator?: (req: any) => string): string {
    if (keyGenerator) {
      return `rate_limit:${keyGenerator(request)}`
    }

    // é»˜è®¤é”®ç”Ÿæˆç­–ç•¥
    const ip = request.ip || request.connection.remoteAddress
    const userId = request.user?.id || 'anonymous'
    const endpoint = `${request.method}:${request.route?.path || request.url}`

    return `rate_limit:${ip}:${userId}:${endpoint}`
  }

  private getDefaultOptions(): RateLimitOptions {
    return {
      windowMs: 60000, // 1åˆ†é’Ÿ
      maxRequests: 100, // 100æ¬¡è¯·æ±‚
      message: 'Too many requests, please try again later',
    }
  }
}
```

---

## ğŸ” å®‰å…¨ç›‘æ§å’Œå®¡è®¡

### å®‰å…¨äº‹ä»¶ç›‘æ§

```typescript
// src/security/monitoring/security-monitor.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'

export enum SecurityEventType {
  LOGIN_ATTEMPT = 'login_attempt',
  LOGIN_SUCCESS = 'login_success',
  LOGIN_FAILURE = 'login_failure',
  PERMISSION_DENIED = 'permission_denied',
  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',
  SUSPICIOUS_ACTIVITY = 'suspicious_activity',
  DATA_ACCESS = 'data_access',
  ADMIN_ACTION = 'admin_action',
}

export interface SecurityEvent {
  type: SecurityEventType
  userId?: string
  ip: string
  userAgent: string
  timestamp: Date
  details: any
  severity: 'low' | 'medium' | 'high' | 'critical'
}

@Injectable()
export class SecurityMonitorService {
  private readonly logger = new Logger(SecurityMonitorService.name)

  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * è®°å½•å®‰å…¨äº‹ä»¶
   */
  async logSecurityEvent(event: SecurityEvent): Promise<void> {
    try {
      // å­˜å‚¨äº‹ä»¶åˆ°Redis
      const eventKey = `security_event:${Date.now()}:${Math.random()}`
      await this.redis.setex(
        eventKey,
        30 * 24 * 60 * 60, // ä¿å­˜30å¤©
        JSON.stringify(event)
      )

      // æ·»åŠ åˆ°äº‹ä»¶ç´¢å¼•
      await this.redis.zadd(
        `security_events:${event.type}`,
        event.timestamp.getTime(),
        eventKey
      )

      // ç”¨æˆ·äº‹ä»¶ç´¢å¼•
      if (event.userId) {
        await this.redis.zadd(
          `user_security_events:${event.userId}`,
          event.timestamp.getTime(),
          eventKey
        )
      }

      // IPäº‹ä»¶ç´¢å¼•
      await this.redis.zadd(
        `ip_security_events:${event.ip}`,
        event.timestamp.getTime(),
        eventKey
      )

      // å®æ—¶å‘Šè­¦æ£€æŸ¥
      await this.checkRealTimeAlerts(event)

      this.logger.log(`Security event logged: ${event.type}`, {
        userId: event.userId,
        ip: event.ip,
        severity: event.severity,
      })
    } catch (error) {
      this.logger.error('Failed to log security event:', error)
    }
  }

  /**
   * æ£€æµ‹å¼‚å¸¸è¡Œä¸º
   */
  async detectAnomalies(userId: string, ip: string): Promise<boolean> {
    const now = Date.now()
    const oneHourAgo = now - 60 * 60 * 1000

    // æ£€æŸ¥ç™»å½•å¤±è´¥æ¬¡æ•°
    const failedLogins = await this.redis.zcount(
      `ip_security_events:${ip}`,
      oneHourAgo,
      now
    )

    if (failedLogins > 10) {
      await this.logSecurityEvent({
        type: SecurityEventType.SUSPICIOUS_ACTIVITY,
        userId,
        ip,
        userAgent: '',
        timestamp: new Date(),
        details: { reason: 'Multiple failed login attempts', count: failedLogins },
        severity: 'high',
      })
      return true
    }

    // æ£€æŸ¥å¼‚å¸¸è®¿é—®æ¨¡å¼
    if (userId) {
      const userEvents = await this.redis.zcount(
        `user_security_events:${userId}`,
        oneHourAgo,
        now
      )

      if (userEvents > 1000) { // 1å°æ—¶å†…è¶…è¿‡1000ä¸ªäº‹ä»¶
        await this.logSecurityEvent({
          type: SecurityEventType.SUSPICIOUS_ACTIVITY,
          userId,
          ip,
          userAgent: '',
          timestamp: new Date(),
          details: { reason: 'High activity volume', count: userEvents },
          severity: 'medium',
        })
        return true
      }
    }

    return false
  }

  /**
   * è·å–å®‰å…¨ç»Ÿè®¡
   */
  async getSecurityStats(timeRange: number = 24 * 60 * 60 * 1000): Promise<any> {
    const now = Date.now()
    const startTime = now - timeRange

    const stats = {}

    // ç»Ÿè®¡å„ç±»äº‹ä»¶æ•°é‡
    for (const eventType of Object.values(SecurityEventType)) {
      const count = await this.redis.zcount(
        `security_events:${eventType}`,
        startTime,
        now
      )
      stats[eventType] = count
    }

    // è·å–æœ€æ´»è·ƒçš„IP
    const topIPs = await this.getTopIPs(startTime, now, 10)

    // è·å–æœ€æ´»è·ƒçš„ç”¨æˆ·
    const topUsers = await this.getTopUsers(startTime, now, 10)

    return {
      eventCounts: stats,
      topIPs,
      topUsers,
      timeRange: timeRange / 1000 / 60 / 60, // è½¬æ¢ä¸ºå°æ—¶
    }
  }

  /**
   * å®æ—¶å‘Šè­¦æ£€æŸ¥
   */
  private async checkRealTimeAlerts(event: SecurityEvent): Promise<void> {
    // å…³é”®äº‹ä»¶ç«‹å³å‘Šè­¦
    if (event.severity === 'critical') {
      await this.sendAlert('CRITICAL', event)
    }

    // æ£€æŸ¥é¢‘ç‡å‘Šè­¦
    if (event.type === SecurityEventType.LOGIN_FAILURE) {
      const recentFailures = await this.redis.zcount(
        `ip_security_events:${event.ip}`,
        Date.now() - 5 * 60 * 1000, // 5åˆ†é’Ÿå†…
        Date.now()
      )

      if (recentFailures >= 5) {
        await this.sendAlert('HIGH_FREQUENCY_FAILURES', event)
      }
    }
  }

  /**
   * å‘é€å‘Šè­¦
   */
  private async sendAlert(alertType: string, event: SecurityEvent): Promise<void> {
    this.logger.warn(`Security Alert: ${alertType}`, {
      event: event.type,
      userId: event.userId,
      ip: event.ip,
      severity: event.severity,
      details: event.details,
    })

    // è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€Slackç­‰å‘Šè­¦æ¸ é“
    // await this.emailService.sendSecurityAlert(alertType, event)
    // await this.slackService.sendSecurityAlert(alertType, event)
  }

  /**
   * è·å–æœ€æ´»è·ƒçš„IP
   */
  private async getTopIPs(startTime: number, endTime: number, limit: number): Promise<any[]> {
    const pattern = 'ip_security_events:*'
    const keys = await this.redis.keys(pattern)

    const ipCounts = []

    for (const key of keys) {
      const ip = key.split(':')[1]
      const count = await this.redis.zcount(key, startTime, endTime)
      if (count > 0) {
        ipCounts.push({ ip, count })
      }
    }

    return ipCounts
      .sort((a, b) => b.count - a.count)
      .slice(0, limit)
  }

  /**
   * è·å–æœ€æ´»è·ƒçš„ç”¨æˆ·
   */
  private async getTopUsers(startTime: number, endTime: number, limit: number): Promise<any[]> {
    const pattern = 'user_security_events:*'
    const keys = await this.redis.keys(pattern)

    const userCounts = []

    for (const key of keys) {
      const userId = key.split(':')[1]
      const count = await this.redis.zcount(key, startTime, endTime)
      if (count > 0) {
        userCounts.push({ userId, count })
      }
    }

    return userCounts
      .sort((a, b) => b.count - a.count)
      .slice(0, limit)
  }
}
```

---

## ğŸ” æ•°æ®åŠ å¯†å’Œä¿æŠ¤

### æ•æ„Ÿæ•°æ®åŠ å¯†

```typescript
// src/security/encryption/encryption.service.ts
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as crypto from 'crypto'
import * as bcrypt from 'bcrypt'

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm'
  private readonly keyLength = 32
  private readonly ivLength = 16
  private readonly tagLength = 16

  constructor(private readonly configService: ConfigService) {}

  /**
   * åŠ å¯†æ•æ„Ÿæ•°æ®
   */
  encrypt(text: string, key?: string): string {
    try {
      const encryptionKey = key || this.getEncryptionKey()
      const iv = crypto.randomBytes(this.ivLength)

      const cipher = crypto.createCipher(this.algorithm, encryptionKey)
      cipher.setAAD(Buffer.from('music-app', 'utf8'))

      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')

      const tag = cipher.getAuthTag()

      // ç»„åˆIVã€tagå’ŒåŠ å¯†æ•°æ®
      const result = iv.toString('hex') + tag.toString('hex') + encrypted

      return Buffer.from(result, 'hex').toString('base64')
    } catch (error) {
      throw new Error('Encryption failed')
    }
  }

  /**
   * è§£å¯†æ•æ„Ÿæ•°æ®
   */
  decrypt(encryptedText: string, key?: string): string {
    try {
      const encryptionKey = key || this.getEncryptionKey()
      const buffer = Buffer.from(encryptedText, 'base64')
      const data = buffer.toString('hex')

      // æå–IVã€tagå’ŒåŠ å¯†æ•°æ®
      const iv = Buffer.from(data.slice(0, this.ivLength * 2), 'hex')
      const tag = Buffer.from(data.slice(this.ivLength * 2, (this.ivLength + this.tagLength) * 2), 'hex')
      const encrypted = data.slice((this.ivLength + this.tagLength) * 2)

      const decipher = crypto.createDecipher(this.algorithm, encryptionKey)
      decipher.setAAD(Buffer.from('music-app', 'utf8'))
      decipher.setAuthTag(tag)

      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')

      return decrypted
    } catch (error) {
      throw new Error('Decryption failed')
    }
  }

  /**
   * å“ˆå¸Œå¯†ç 
   */
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12
    return bcrypt.hash(password, saltRounds)
  }

  /**
   * éªŒè¯å¯†ç 
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }

  /**
   * ç”Ÿæˆå®‰å…¨çš„éšæœºå­—ç¬¦ä¸²
   */
  generateSecureRandom(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex')
  }

  /**
   * ç”Ÿæˆå“ˆå¸Œ
   */
  generateHash(data: string, algorithm: string = 'sha256'): string {
    return crypto.createHash(algorithm).update(data).digest('hex')
  }

  /**
   * HMACç­¾å
   */
  generateHMAC(data: string, secret?: string): string {
    const hmacSecret = secret || this.getHMACSecret()
    return crypto.createHmac('sha256', hmacSecret).update(data).digest('hex')
  }

  /**
   * éªŒè¯HMACç­¾å
   */
  verifyHMAC(data: string, signature: string, secret?: string): boolean {
    const expectedSignature = this.generateHMAC(data, secret)
    return crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    )
  }

  /**
   * è·å–åŠ å¯†å¯†é’¥
   */
  private getEncryptionKey(): string {
    const key = this.configService.get<string>('ENCRYPTION_KEY')
    if (!key || key.length < this.keyLength) {
      throw new Error('Invalid encryption key')
    }
    return key.slice(0, this.keyLength)
  }

  /**
   * è·å–HMACå¯†é’¥
   */
  private getHMACSecret(): string {
    const secret = this.configService.get<string>('HMAC_SECRET')
    if (!secret) {
      throw new Error('HMAC secret not configured')
    }
    return secret
  }
}
```

---

## ğŸ§ª å®‰å…¨æµ‹è¯•

### å®‰å…¨æµ‹è¯•å¥—ä»¶

```typescript
// src/security/testing/security.spec.ts
import { Test, TestingModule } from '@nestjs/testing'
import { EnhancedJwtService } from '../enhanced-jwt.service'
import { EncryptionService } from '../encryption/encryption.service'
import { SecurityMonitorService } from '../monitoring/security-monitor.service'

describe('Security Services', () => {
  let jwtService: EnhancedJwtService
  let encryptionService: EncryptionService
  let monitorService: SecurityMonitorService

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        EnhancedJwtService,
        EncryptionService,
        SecurityMonitorService,
        // Mock providers
      ],
    }).compile()

    jwtService = module.get<EnhancedJwtService>(EnhancedJwtService)
    encryptionService = module.get<EncryptionService>(EncryptionService)
    monitorService = module.get<SecurityMonitorService>(SecurityMonitorService)
  })

  describe('JWT Security', () => {
    it('should generate secure tokens with device fingerprint', async () => {
      const user = { id: 'test-user', username: 'testuser' }
      const deviceInfo = {
        userAgent: 'Mozilla/5.0...',
        ip: '192.168.1.1',
        acceptLanguage: 'en-US',
        timezone: 'UTC',
      }

      const result = await jwtService.generateSecureToken(user, deviceInfo)

      expect(result.accessToken).toBeDefined()
      expect(result.refreshToken).toBeDefined()
      expect(result.fingerprint).toBeDefined()
    })

    it('should reject tokens with mismatched device fingerprint', async () => {
      const user = { id: 'test-user', username: 'testuser' }
      const deviceInfo1 = { userAgent: 'Chrome', ip: '192.168.1.1' }
      const deviceInfo2 = { userAgent: 'Firefox', ip: '192.168.1.2' }

      const { accessToken } = await jwtService.generateSecureToken(user, deviceInfo1)

      await expect(
        jwtService.verifySecureToken(accessToken, deviceInfo2)
      ).rejects.toThrow('Device fingerprint mismatch')
    })
  })

  describe('Encryption', () => {
    it('should encrypt and decrypt data correctly', () => {
      const plaintext = 'sensitive data'

      const encrypted = encryptionService.encrypt(plaintext)
      const decrypted = encryptionService.decrypt(encrypted)

      expect(decrypted).toBe(plaintext)
      expect(encrypted).not.toBe(plaintext)
    })

    it('should hash and verify passwords', async () => {
      const password = 'testpassword123'

      const hash = await encryptionService.hashPassword(password)
      const isValid = await encryptionService.verifyPassword(password, hash)

      expect(isValid).toBe(true)
      expect(hash).not.toBe(password)
    })

    it('should generate and verify HMAC signatures', () => {
      const data = 'test data'

      const signature = encryptionService.generateHMAC(data)
      const isValid = encryptionService.verifyHMAC(data, signature)

      expect(isValid).toBe(true)
    })
  })

  describe('Security Monitoring', () => {
    it('should log security events', async () => {
      const event = {
        type: SecurityEventType.LOGIN_ATTEMPT,
        userId: 'test-user',
        ip: '192.168.1.1',
        userAgent: 'Mozilla/5.0...',
        timestamp: new Date(),
        details: { method: 'password' },
        severity: 'low' as const,
      }

      await expect(
        monitorService.logSecurityEvent(event)
      ).resolves.not.toThrow()
    })

    it('should detect anomalies', async () => {
      const userId = 'test-user'
      const ip = '192.168.1.1'

      // æ¨¡æ‹Ÿå¤šæ¬¡å¤±è´¥ç™»å½•
      for (let i = 0; i < 15; i++) {
        await monitorService.logSecurityEvent({
          type: SecurityEventType.LOGIN_FAILURE,
          userId,
          ip,
          userAgent: 'Mozilla/5.0...',
          timestamp: new Date(),
          details: { attempt: i + 1 },
          severity: 'medium',
        })
      }

      const hasAnomaly = await monitorService.detectAnomalies(userId, ip)
      expect(hasAnomaly).toBe(true)
    })
  })
})
```

---

## ğŸ”§ å®‰å…¨é…ç½®å’Œæœ€ä½³å®è·µ

### å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•

```markdown
## ğŸ”’ å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•

### ç¯å¢ƒé…ç½®
- [ ] ä½¿ç”¨å¼ºå¯†é’¥ï¼ˆè‡³å°‘32å­—ç¬¦ï¼‰
- [ ] å¯ç”¨HTTPS/TLS
- [ ] é…ç½®å®‰å…¨çš„CORSç­–ç•¥
- [ ] è®¾ç½®å®‰å…¨çš„Cookieé€‰é¡¹
- [ ] ç¦ç”¨ä¸å¿…è¦çš„HTTPæ–¹æ³•

### è®¤è¯å’Œæˆæƒ
- [ ] å®æ–½å¼ºå¯†ç ç­–ç•¥
- [ ] å¯ç”¨åŒå› ç´ è®¤è¯
- [ ] é…ç½®JWTå®‰å…¨å‚æ•°
- [ ] å®æ–½æƒé™æœ€å°åŒ–åŸåˆ™
- [ ] å®šæœŸè½®æ¢å¯†é’¥

### è¾“å…¥éªŒè¯
- [ ] éªŒè¯æ‰€æœ‰ç”¨æˆ·è¾“å…¥
- [ ] å®æ–½SQLæ³¨å…¥é˜²æŠ¤
- [ ] å¯ç”¨XSSé˜²æŠ¤
- [ ] é…ç½®CSRFä¿æŠ¤
- [ ] é™åˆ¶æ–‡ä»¶ä¸Šä¼ ç±»å‹å’Œå¤§å°

### ç›‘æ§å’Œæ—¥å¿—
- [ ] å¯ç”¨å®‰å…¨äº‹ä»¶æ—¥å¿—
- [ ] é…ç½®å®æ—¶å‘Šè­¦
- [ ] å®æ–½å¼‚å¸¸æ£€æµ‹
- [ ] å®šæœŸå®‰å…¨å®¡è®¡
- [ ] å¤‡ä»½å’Œæ¢å¤æµ‹è¯•

### ç½‘ç»œå®‰å…¨
- [ ] é…ç½®é˜²ç«å¢™è§„åˆ™
- [ ] å¯ç”¨DDoSé˜²æŠ¤
- [ ] ä½¿ç”¨å®‰å…¨çš„DNS
- [ ] å®æ–½ç½‘ç»œåˆ†æ®µ
- [ ] å®šæœŸå®‰å…¨æ‰«æ
```

### å®‰å…¨äº‹ä»¶å“åº”æµç¨‹

```typescript
// src/security/incident/incident-response.service.ts
import { Injectable, Logger } from '@nestjs/common'

export enum IncidentSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface SecurityIncident {
  id: string
  type: string
  severity: IncidentSeverity
  description: string
  affectedSystems: string[]
  detectedAt: Date
  status: 'open' | 'investigating' | 'contained' | 'resolved'
  assignedTo?: string
  actions: IncidentAction[]
}

export interface IncidentAction {
  timestamp: Date
  action: string
  performedBy: string
  result: string
}

@Injectable()
export class IncidentResponseService {
  private readonly logger = new Logger(IncidentResponseService.name)

  /**
   * åˆ›å»ºå®‰å…¨äº‹ä»¶
   */
  async createIncident(incident: Partial<SecurityIncident>): Promise<SecurityIncident> {
    const newIncident: SecurityIncident = {
      id: this.generateIncidentId(),
      type: incident.type || 'unknown',
      severity: incident.severity || IncidentSeverity.MEDIUM,
      description: incident.description || '',
      affectedSystems: incident.affectedSystems || [],
      detectedAt: new Date(),
      status: 'open',
      actions: [],
    }

    // æ ¹æ®ä¸¥é‡æ€§è‡ªåŠ¨åˆ†é…
    if (newIncident.severity === IncidentSeverity.CRITICAL) {
      await this.escalateIncident(newIncident)
    }

    this.logger.warn(`Security incident created: ${newIncident.id}`, newIncident)

    return newIncident
  }

  /**
   * å‡çº§äº‹ä»¶
   */
  private async escalateIncident(incident: SecurityIncident): Promise<void> {
    // ç«‹å³é€šçŸ¥å®‰å…¨å›¢é˜Ÿ
    await this.notifySecurityTeam(incident)

    // è‡ªåŠ¨æ‰§è¡Œç´§æ€¥å“åº”æªæ–½
    await this.executeEmergencyResponse(incident)
  }

  /**
   * é€šçŸ¥å®‰å…¨å›¢é˜Ÿ
   */
  private async notifySecurityTeam(incident: SecurityIncident): Promise<void> {
    this.logger.error(`CRITICAL SECURITY INCIDENT: ${incident.id}`, incident)

    // è¿™é‡Œåº”è¯¥é›†æˆå®é™…çš„é€šçŸ¥ç³»ç»Ÿ
    // await this.emailService.sendCriticalAlert(incident)
    // await this.smsService.sendEmergencyAlert(incident)
    // await this.slackService.sendIncidentAlert(incident)
  }

  /**
   * æ‰§è¡Œç´§æ€¥å“åº”
   */
  private async executeEmergencyResponse(incident: SecurityIncident): Promise<void> {
    // æ ¹æ®äº‹ä»¶ç±»å‹æ‰§è¡Œç›¸åº”çš„å“åº”æªæ–½
    switch (incident.type) {
      case 'brute_force_attack':
        await this.blockSuspiciousIPs(incident)
        break
      case 'data_breach':
        await this.isolateAffectedSystems(incident)
        break
      case 'malware_detected':
        await this.quarantineSystem(incident)
        break
    }
  }

  private async blockSuspiciousIPs(incident: SecurityIncident): Promise<void> {
    // å®æ–½IPé˜»æ–­é€»è¾‘
    this.logger.log(`Blocking suspicious IPs for incident: ${incident.id}`)
  }

  private async isolateAffectedSystems(incident: SecurityIncident): Promise<void> {
    // éš”ç¦»å—å½±å“çš„ç³»ç»Ÿ
    this.logger.log(`Isolating affected systems for incident: ${incident.id}`)
  }

  private async quarantineSystem(incident: SecurityIncident): Promise<void> {
    // éš”ç¦»ç³»ç»Ÿ
    this.logger.log(`Quarantining system for incident: ${incident.id}`)
  }

  private generateIncidentId(): string {
    const timestamp = Date.now().toString(36)
    const random = Math.random().toString(36).substr(2, 5)
    return `INC-${timestamp}-${random}`.toUpperCase()
  }
}
```

---

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å¤šå±‚å®‰å…¨é˜²æŠ¤ä½“ç³»çš„è®¾è®¡å’Œå®ç°ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€æƒé™æ§åˆ¶ã€è¾“å…¥éªŒè¯ã€CSRFé˜²æŠ¤ã€é€Ÿç‡é™åˆ¶ã€å®‰å…¨ç›‘æ§ç­‰æ ¸å¿ƒå®‰å…¨æœºåˆ¶ã€‚*
```
