# ğŸš€ ç¼“å­˜ç­–ç•¥æŠ€æœ¯æ–‡æ¡£

**æŠ€æœ¯æ ˆ**: Redis + NestJS + Vue 3  
**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-06-27

---

## ğŸ“‹ ç¼“å­˜ç­–ç•¥æ¦‚è§ˆ

ç¼“å­˜ç³»ç»Ÿé‡‡ç”¨å¤šå±‚ç¼“å­˜æ¶æ„ï¼ŒåŒ…æ‹¬Redisåˆ†å¸ƒå¼ç¼“å­˜ã€åº”ç”¨å†…å­˜ç¼“å­˜å’Œæµè§ˆå™¨ç¼“å­˜ï¼Œé€šè¿‡åˆç†çš„ç¼“å­˜ç­–ç•¥æ˜¾è‘—æå‡ç³»ç»Ÿæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

### ğŸ—ï¸ ç¼“å­˜æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æµè§ˆå™¨ç¼“å­˜    â”‚    â”‚   CDNç¼“å­˜       â”‚    â”‚   åº”ç”¨å±‚ç¼“å­˜    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ HTTPç¼“å­˜      â”‚â—„â”€â”€â–ºâ”‚ â€¢ é™æ€èµ„æº      â”‚â—„â”€â”€â–ºâ”‚ â€¢ å†…å­˜ç¼“å­˜      â”‚
â”‚ â€¢ LocalStorage  â”‚    â”‚ â€¢ å›¾ç‰‡éŸ³é¢‘      â”‚    â”‚ â€¢ æŸ¥è¯¢ç¼“å­˜      â”‚
â”‚ â€¢ SessionStorageâ”‚    â”‚ â€¢ å…¨çƒåˆ†å‘      â”‚    â”‚ â€¢ ä¼šè¯ç¼“å­˜      â”‚
â”‚ â€¢ IndexedDB     â”‚    â”‚ â€¢ è¾¹ç¼˜èŠ‚ç‚¹      â”‚    â”‚ â€¢ è®¡ç®—ç»“æœ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Redisç¼“å­˜     â”‚    â”‚   æ•°æ®åº“ç¼“å­˜    â”‚    â”‚   æ–‡ä»¶ç³»ç»Ÿç¼“å­˜  â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ åˆ†å¸ƒå¼ç¼“å­˜    â”‚    â”‚ â€¢ æŸ¥è¯¢ç¼“å­˜      â”‚    â”‚ â€¢ é™æ€æ–‡ä»¶      â”‚
â”‚ â€¢ ä¼šè¯å­˜å‚¨      â”‚    â”‚ â€¢ è¿æ¥æ±         â”‚    â”‚ â€¢ ä¸Šä¼ æ–‡ä»¶      â”‚
â”‚ â€¢ æ¶ˆæ¯é˜Ÿåˆ—      â”‚    â”‚ â€¢ ç´¢å¼•ç¼“å­˜      â”‚    â”‚ â€¢ ä¸´æ—¶æ–‡ä»¶      â”‚
â”‚ â€¢ å®æ—¶æ•°æ®      â”‚    â”‚ â€¢ ç»“æœé›†ç¼“å­˜    â”‚    â”‚ â€¢ æ—¥å¿—æ–‡ä»¶      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Redisç¼“å­˜é…ç½®

### Redisæ¨¡å—é…ç½®

```typescript
// src/cache/cache.module.ts
import { Module, Global } from '@nestjs/common'
import { RedisModule } from '@nestjs-modules/ioredis'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { CacheService } from './cache.service'
import { CacheInterceptor } from './interceptors/cache.interceptor'

@Global()
@Module({
  imports: [
    RedisModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        type: 'single',
        url: `redis://${configService.get('redis.host')}:${configService.get('redis.port')}`,
        options: {
          password: configService.get('redis.password'),
          db: configService.get('redis.database') || 0,
          retryDelayOnFailover: 100,
          maxRetriesPerRequest: 3,
          lazyConnect: true,
          keepAlive: 30000,
          family: 4,
          keyPrefix: configService.get('redis.keyPrefix') || 'music-app:',
        },
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [CacheService, CacheInterceptor],
  exports: [CacheService, CacheInterceptor],
})
export class CacheModule {}
```

### ç¼“å­˜é…ç½®

```typescript
// src/config/cache.config.ts
import { registerAs } from '@nestjs/config'

export default registerAs('cache', () => ({
  // Redisé…ç½®
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    database: parseInt(process.env.REDIS_DATABASE || '0'),
    keyPrefix: process.env.REDIS_KEY_PREFIX || 'music-app:',
  },

  // ç¼“å­˜ç­–ç•¥é…ç½®
  strategies: {
    // ç”¨æˆ·æ•°æ®ç¼“å­˜
    user: {
      ttl: 3600, // 1å°æ—¶
      maxSize: 1000,
      refreshThreshold: 0.8,
    },
    
    // æ­Œæ›²æ•°æ®ç¼“å­˜
    song: {
      ttl: 7200, // 2å°æ—¶
      maxSize: 5000,
      refreshThreshold: 0.9,
    },
    
    // æ­Œå•æ•°æ®ç¼“å­˜
    playlist: {
      ttl: 1800, // 30åˆ†é’Ÿ
      maxSize: 2000,
      refreshThreshold: 0.8,
    },
    
    // æœç´¢ç»“æœç¼“å­˜
    search: {
      ttl: 900, // 15åˆ†é’Ÿ
      maxSize: 1000,
      refreshThreshold: 0.7,
    },
    
    // çƒ­é—¨æ•°æ®ç¼“å­˜
    popular: {
      ttl: 300, // 5åˆ†é’Ÿ
      maxSize: 100,
      refreshThreshold: 0.9,
    },
    
    // ä¼šè¯ç¼“å­˜
    session: {
      ttl: 86400, // 24å°æ—¶
      maxSize: 10000,
      refreshThreshold: 0.9,
    },
  },

  // å†…å­˜ç¼“å­˜é…ç½®
  memory: {
    maxSize: 100, // æœ€å¤§ç¼“å­˜é¡¹æ•°
    ttl: 300, // 5åˆ†é’Ÿ
    checkPeriod: 60, // æ¸…ç†æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
  },

  // ç¼“å­˜é¢„çƒ­é…ç½®
  warmup: {
    enabled: true,
    strategies: ['popular', 'user'],
    interval: 3600, // 1å°æ—¶é¢„çƒ­ä¸€æ¬¡
  },
}))
```

---

## ğŸ› ï¸ ç¼“å­˜æœåŠ¡å®ç°

### æ ¸å¿ƒç¼“å­˜æœåŠ¡

```typescript
// src/cache/cache.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import { ConfigService } from '@nestjs/config'
import Redis from 'ioredis'
import { LRUCache } from 'lru-cache'

interface CacheOptions {
  ttl?: number
  tags?: string[]
  compress?: boolean
  serialize?: boolean
}

interface CacheStats {
  hits: number
  misses: number
  sets: number
  deletes: number
  hitRate: number
}

@Injectable()
export class CacheService {
  private readonly logger = new Logger(CacheService.name)
  private readonly memoryCache: LRUCache<string, any>
  private readonly stats: CacheStats = {
    hits: 0,
    misses: 0,
    sets: 0,
    deletes: 0,
    hitRate: 0,
  }

  constructor(
    @InjectRedis() private readonly redis: Redis,
    private readonly configService: ConfigService,
  ) {
    // åˆå§‹åŒ–å†…å­˜ç¼“å­˜
    const memoryConfig = this.configService.get('cache.memory')
    this.memoryCache = new LRUCache({
      max: memoryConfig.maxSize,
      ttl: memoryConfig.ttl * 1000, // è½¬æ¢ä¸ºæ¯«ç§’
    })

    // å®šæœŸæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    setInterval(() => this.updateStats(), 60000) // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡
  }

  /**
   * è·å–ç¼“å­˜æ•°æ®
   */
  async get<T>(key: string, useMemoryCache: boolean = true): Promise<T | null> {
    try {
      // 1. å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
      if (useMemoryCache && this.memoryCache.has(key)) {
        this.stats.hits++
        return this.memoryCache.get(key) as T
      }

      // 2. æ£€æŸ¥Redisç¼“å­˜
      const cached = await this.redis.get(key)
      if (cached) {
        this.stats.hits++
        const data = this.deserialize(cached)
        
        // å›å†™åˆ°å†…å­˜ç¼“å­˜
        if (useMemoryCache) {
          this.memoryCache.set(key, data)
        }
        
        return data as T
      }

      this.stats.misses++
      return null
    } catch (error) {
      this.logger.error(`Cache get error for key ${key}:`, error)
      this.stats.misses++
      return null
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜æ•°æ®
   */
  async set(
    key: string,
    value: any,
    options: CacheOptions = {}
  ): Promise<void> {
    try {
      const {
        ttl = 3600,
        tags = [],
        compress = false,
        serialize = true,
      } = options

      const serializedValue = serialize ? this.serialize(value) : value

      // è®¾ç½®Redisç¼“å­˜
      if (ttl > 0) {
        await this.redis.setex(key, ttl, serializedValue)
      } else {
        await this.redis.set(key, serializedValue)
      }

      // è®¾ç½®å†…å­˜ç¼“å­˜
      this.memoryCache.set(key, value)

      // å¤„ç†æ ‡ç­¾
      if (tags.length > 0) {
        await this.addTags(key, tags)
      }

      this.stats.sets++
      this.logger.debug(`Cache set: ${key} (TTL: ${ttl}s)`)
    } catch (error) {
      this.logger.error(`Cache set error for key ${key}:`, error)
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜
   */
  async del(key: string | string[]): Promise<number> {
    try {
      const keys = Array.isArray(key) ? key : [key]
      
      // ä»å†…å­˜ç¼“å­˜åˆ é™¤
      keys.forEach(k => this.memoryCache.delete(k))
      
      // ä»Redisåˆ é™¤
      const result = await this.redis.del(...keys)
      
      this.stats.deletes += keys.length
      this.logger.debug(`Cache deleted: ${keys.join(', ')}`)
      
      return result
    } catch (error) {
      this.logger.error(`Cache delete error:`, error)
      return 0
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
   */
  async exists(key: string): Promise<boolean> {
    try {
      if (this.memoryCache.has(key)) {
        return true
      }
      
      const result = await this.redis.exists(key)
      return result === 1
    } catch (error) {
      this.logger.error(`Cache exists error for key ${key}:`, error)
      return false
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜è¿‡æœŸæ—¶é—´
   */
  async expire(key: string, ttl: number): Promise<boolean> {
    try {
      const result = await this.redis.expire(key, ttl)
      return result === 1
    } catch (error) {
      this.logger.error(`Cache expire error for key ${key}:`, error)
      return false
    }
  }

  /**
   * è·å–ç¼“å­˜å‰©ä½™æ—¶é—´
   */
  async ttl(key: string): Promise<number> {
    try {
      return await this.redis.ttl(key)
    } catch (error) {
      this.logger.error(`Cache TTL error for key ${key}:`, error)
      return -1
    }
  }

  /**
   * æ‰¹é‡è·å–ç¼“å­˜
   */
  async mget<T>(keys: string[]): Promise<(T | null)[]> {
    try {
      const results = await this.redis.mget(...keys)
      return results.map(result => 
        result ? this.deserialize(result) as T : null
      )
    } catch (error) {
      this.logger.error(`Cache mget error:`, error)
      return keys.map(() => null)
    }
  }

  /**
   * æ‰¹é‡è®¾ç½®ç¼“å­˜
   */
  async mset(data: Record<string, any>, ttl: number = 3600): Promise<void> {
    try {
      const pipeline = this.redis.pipeline()
      
      Object.entries(data).forEach(([key, value]) => {
        const serializedValue = this.serialize(value)
        pipeline.setex(key, ttl, serializedValue)
        this.memoryCache.set(key, value)
      })
      
      await pipeline.exec()
      this.stats.sets += Object.keys(data).length
    } catch (error) {
      this.logger.error(`Cache mset error:`, error)
    }
  }

  /**
   * åŸå­é€’å¢
   */
  async incr(key: string, delta: number = 1): Promise<number> {
    try {
      return await this.redis.incrby(key, delta)
    } catch (error) {
      this.logger.error(`Cache incr error for key ${key}:`, error)
      return 0
    }
  }

  /**
   * åŸå­é€’å‡
   */
  async decr(key: string, delta: number = 1): Promise<number> {
    try {
      return await this.redis.decrby(key, delta)
    } catch (error) {
      this.logger.error(`Cache decr error for key ${key}:`, error)
      return 0
    }
  }

  /**
   * è·å–æˆ–è®¾ç½®ç¼“å­˜ï¼ˆç¼“å­˜ç©¿é€ä¿æŠ¤ï¼‰
   */
  async getOrSet<T>(
    key: string,
    factory: () => Promise<T>,
    options: CacheOptions = {}
  ): Promise<T> {
    // å…ˆå°è¯•è·å–ç¼“å­˜
    const cached = await this.get<T>(key)
    if (cached !== null) {
      return cached
    }

    // ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
    const lockKey = `lock:${key}`
    const lockValue = Date.now().toString()
    
    try {
      // å°è¯•è·å–é”
      const acquired = await this.redis.set(lockKey, lockValue, 'PX', 5000, 'NX')
      
      if (acquired) {
        // è·å¾—é”ï¼Œæ‰§è¡Œå·¥å‚å‡½æ•°
        const data = await factory()
        await this.set(key, data, options)
        
        // é‡Šæ”¾é”
        await this.releaseLock(lockKey, lockValue)
        
        return data
      } else {
        // æœªè·å¾—é”ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
        await this.sleep(100)
        return this.getOrSet(key, factory, options)
      }
    } catch (error) {
      // ç¡®ä¿é”è¢«é‡Šæ”¾
      await this.releaseLock(lockKey, lockValue)
      throw error
    }
  }

  /**
   * æ ¹æ®æ ‡ç­¾åˆ é™¤ç¼“å­˜
   */
  async deleteByTags(tags: string[]): Promise<number> {
    try {
      let deletedCount = 0
      
      for (const tag of tags) {
        const tagKey = `tag:${tag}`
        const keys = await this.redis.smembers(tagKey)
        
        if (keys.length > 0) {
          deletedCount += await this.del(keys)
          await this.redis.del(tagKey)
        }
      }
      
      return deletedCount
    } catch (error) {
      this.logger.error(`Delete by tags error:`, error)
      return 0
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  async flush(): Promise<void> {
    try {
      await this.redis.flushdb()
      this.memoryCache.clear()
      this.logger.log('Cache flushed')
    } catch (error) {
      this.logger.error(`Cache flush error:`, error)
    }
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): CacheStats {
    return { ...this.stats }
  }

  /**
   * è·å–ç¼“å­˜ä¿¡æ¯
   */
  async getInfo(): Promise<any> {
    try {
      const info = await this.redis.info('memory')
      const keyspace = await this.redis.info('keyspace')
      
      return {
        redis: {
          memory: info,
          keyspace: keyspace,
        },
        memory: {
          size: this.memoryCache.size,
          max: this.memoryCache.max,
        },
        stats: this.getStats(),
      }
    } catch (error) {
      this.logger.error(`Get cache info error:`, error)
      return null
    }
  }

  /**
   * åºåˆ—åŒ–æ•°æ®
   */
  private serialize(data: any): string {
    try {
      return JSON.stringify(data)
    } catch (error) {
      this.logger.error('Serialize error:', error)
      return String(data)
    }
  }

  /**
   * ååºåˆ—åŒ–æ•°æ®
   */
  private deserialize(data: string): any {
    try {
      return JSON.parse(data)
    } catch (error) {
      return data
    }
  }

  /**
   * æ·»åŠ æ ‡ç­¾
   */
  private async addTags(key: string, tags: string[]): Promise<void> {
    const pipeline = this.redis.pipeline()
    
    tags.forEach(tag => {
      const tagKey = `tag:${tag}`
      pipeline.sadd(tagKey, key)
      pipeline.expire(tagKey, 86400) // æ ‡ç­¾24å°æ—¶è¿‡æœŸ
    })
    
    await pipeline.exec()
  }

  /**
   * é‡Šæ”¾åˆ†å¸ƒå¼é”
   */
  private async releaseLock(lockKey: string, lockValue: string): Promise<void> {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `
    
    await this.redis.eval(script, 1, lockKey, lockValue)
  }

  /**
   * ç¡çœ å‡½æ•°
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  /**
   * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   */
  private updateStats(): void {
    const total = this.stats.hits + this.stats.misses
    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0
  }
}
```

---

## ğŸ¯ ç¼“å­˜æ‹¦æˆªå™¨

### è‡ªåŠ¨ç¼“å­˜æ‹¦æˆªå™¨

```typescript
// src/cache/interceptors/cache.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { Observable, of } from 'rxjs'
import { tap } from 'rxjs/operators'
import { CacheService } from '../cache.service'

interface CacheConfig {
  key?: string
  ttl?: number
  tags?: string[]
  condition?: (context: ExecutionContext) => boolean
}

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  constructor(
    private readonly cacheService: CacheService,
    private readonly reflector: Reflector,
  ) {}

  async intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Promise<Observable<any>> {
    const cacheConfig = this.reflector.get<CacheConfig>(
      'cache',
      context.getHandler(),
    )

    if (!cacheConfig) {
      return next.handle()
    }

    // æ£€æŸ¥ç¼“å­˜æ¡ä»¶
    if (cacheConfig.condition && !cacheConfig.condition(context)) {
      return next.handle()
    }

    const request = context.switchToHttp().getRequest()
    const cacheKey = this.generateCacheKey(cacheConfig.key, request)

    // å°è¯•ä»ç¼“å­˜è·å–æ•°æ®
    const cachedData = await this.cacheService.get(cacheKey)
    if (cachedData !== null) {
      return of(cachedData)
    }

    // æ‰§è¡ŒåŸæ–¹æ³•å¹¶ç¼“å­˜ç»“æœ
    return next.handle().pipe(
      tap(async (data) => {
        if (data !== null && data !== undefined) {
          await this.cacheService.set(cacheKey, data, {
            ttl: cacheConfig.ttl || 3600,
            tags: cacheConfig.tags || [],
          })
        }
      }),
    )
  }

  private generateCacheKey(keyTemplate: string, request: any): string {
    if (!keyTemplate) {
      // é»˜è®¤ç¼“å­˜é”®ç”Ÿæˆç­–ç•¥
      const { method, url, query, user } = request
      const userId = user?.id || 'anonymous'
      const queryString = new URLSearchParams(query).toString()
      return `${method}:${url}:${userId}:${queryString}`
    }

    // æ›¿æ¢æ¨¡æ¿ä¸­çš„å ä½ç¬¦
    return keyTemplate
      .replace('{userId}', request.user?.id || 'anonymous')
      .replace('{method}', request.method)
      .replace('{url}', request.url)
      .replace('{query}', new URLSearchParams(request.query).toString())
  }
}
```

### ç¼“å­˜è£…é¥°å™¨

```typescript
// src/cache/decorators/cache.decorator.ts
import { SetMetadata } from '@nestjs/common'
import { ExecutionContext } from '@nestjs/common'

interface CacheOptions {
  key?: string
  ttl?: number
  tags?: string[]
  condition?: (context: ExecutionContext) => boolean
}

export const Cache = (options: CacheOptions = {}) =>
  SetMetadata('cache', options)

export const CacheKey = (key: string) =>
  SetMetadata('cache', { key })

export const CacheTTL = (ttl: number) =>
  SetMetadata('cache', { ttl })

export const CacheTags = (...tags: string[]) =>
  SetMetadata('cache', { tags })

// ä½¿ç”¨ç¤ºä¾‹
export const CacheUser = () =>
  Cache({
    key: 'user:{userId}',
    ttl: 3600,
    tags: ['user'],
    condition: (context) => {
      const request = context.switchToHttp().getRequest()
      return !!request.user?.id
    },
  })

export const CacheSong = () =>
  Cache({
    key: 'song:{songId}',
    ttl: 7200,
    tags: ['song'],
  })

export const CachePlaylist = () =>
  Cache({
    key: 'playlist:{playlistId}',
    ttl: 1800,
    tags: ['playlist'],
  })
```

---

## ğŸµ ä¸šåŠ¡ç¼“å­˜ç­–ç•¥

### ç”¨æˆ·æ•°æ®ç¼“å­˜

```typescript
// src/users/users.service.ts
import { Injectable } from '@nestjs/common'
import { CacheService } from '../cache/cache.service'
import { Cache, CacheUser } from '../cache/decorators/cache.decorator'

@Injectable()
export class UsersService {
  constructor(private readonly cacheService: CacheService) {}

  @CacheUser()
  async findById(id: string) {
    // æ–¹æ³•ä¼šè¢«è‡ªåŠ¨ç¼“å­˜
    return this.userRepository.findOne({ where: { id } })
  }

  async updateUser(id: string, updateData: any) {
    const user = await this.userRepository.update(id, updateData)

    // æ›´æ–°åæ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.cacheService.deleteByTags(['user'])
    await this.cacheService.del(`user:${id}`)

    return user
  }

  async getUserProfile(userId: string) {
    const cacheKey = `user:profile:${userId}`

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        // å¤æ‚çš„ç”¨æˆ·æ¡£æ¡ˆæŸ¥è¯¢
        const user = await this.userRepository.findOne({
          where: { id: userId },
          relations: ['playlists', 'favorites', 'followers'],
        })

        return {
          ...user,
          playlistCount: user.playlists.length,
          favoriteCount: user.favorites.length,
          followerCount: user.followers.length,
        }
      },
      { ttl: 1800, tags: ['user', 'profile'] }
    )
  }
}
```

### éŸ³ä¹æ•°æ®ç¼“å­˜

```typescript
// src/songs/songs.service.ts
import { Injectable } from '@nestjs/common'
import { CacheService } from '../cache/cache.service'

@Injectable()
export class SongsService {
  constructor(private readonly cacheService: CacheService) {}

  async getPopularSongs(limit: number = 50) {
    const cacheKey = `songs:popular:${limit}`

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        return this.songRepository.find({
          order: { playCount: 'DESC' },
          take: limit,
        })
      },
      { ttl: 300, tags: ['song', 'popular'] } // 5åˆ†é’Ÿç¼“å­˜
    )
  }

  async searchSongs(query: string, page: number = 1, limit: number = 20) {
    const cacheKey = `songs:search:${query}:${page}:${limit}`

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        return this.songRepository
          .createQueryBuilder('song')
          .where('song.title LIKE :query OR song.artist LIKE :query', {
            query: `%${query}%`,
          })
          .skip((page - 1) * limit)
          .take(limit)
          .getMany()
      },
      { ttl: 900, tags: ['song', 'search'] } // 15åˆ†é’Ÿç¼“å­˜
    )
  }

  async incrementPlayCount(songId: string) {
    // ä½¿ç”¨RedisåŸå­æ“ä½œ
    const playCountKey = `song:playcount:${songId}`
    const newCount = await this.cacheService.incr(playCountKey)

    // æ¯100æ¬¡æ’­æ”¾æ›´æ–°ä¸€æ¬¡æ•°æ®åº“
    if (newCount % 100 === 0) {
      await this.songRepository.update(songId, {
        playCount: () => `playCount + ${newCount}`,
      })
      await this.cacheService.del(playCountKey)
    }

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.cacheService.deleteByTags(['popular'])

    return newCount
  }
}
```

### æ­Œå•æ•°æ®ç¼“å­˜

```typescript
// src/playlists/playlists.service.ts
import { Injectable } from '@nestjs/common'
import { CacheService } from '../cache/cache.service'

@Injectable()
export class PlaylistsService {
  constructor(private readonly cacheService: CacheService) {}

  async getPlaylistWithSongs(playlistId: string) {
    const cacheKey = `playlist:detail:${playlistId}`

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        return this.playlistRepository.findOne({
          where: { id: playlistId },
          relations: ['songs', 'user'],
        })
      },
      { ttl: 1800, tags: ['playlist'] } // 30åˆ†é’Ÿç¼“å­˜
    )
  }

  async addSongToPlaylist(playlistId: string, songId: string) {
    // æ·»åŠ æ­Œæ›²åˆ°æ­Œå•
    await this.playlistSongRepository.save({
      playlistId,
      songId,
      addedAt: new Date(),
    })

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.cacheService.del(`playlist:detail:${playlistId}`)
    await this.cacheService.deleteByTags(['playlist'])

    return { success: true }
  }

  async getUserPlaylists(userId: string) {
    const cacheKey = `user:playlists:${userId}`

    return this.cacheService.getOrSet(
      cacheKey,
      async () => {
        return this.playlistRepository.find({
          where: { userId },
          order: { createdAt: 'DESC' },
        })
      },
      { ttl: 3600, tags: ['playlist', 'user'] } // 1å°æ—¶ç¼“å­˜
    )
  }
}
```

---

## ğŸŒ å‰ç«¯ç¼“å­˜ç­–ç•¥

### Vue 3ç¼“å­˜ç»„åˆå¼å‡½æ•°

```typescript
// src/composables/useCache.ts
import { ref, computed } from 'vue'

interface CacheItem<T> {
  data: T
  timestamp: number
  ttl: number
}

class FrontendCache {
  private cache = new Map<string, CacheItem<any>>()
  private readonly defaultTTL = 5 * 60 * 1000 // 5åˆ†é’Ÿ

  set<T>(key: string, data: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    })
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key)

    if (!item) {
      return null
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key)
      return null
    }

    return item.data as T
  }

  has(key: string): boolean {
    return this.get(key) !== null
  }

  delete(key: string): void {
    this.cache.delete(key)
  }

  clear(): void {
    this.cache.clear()
  }

  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanup(): void {
    const now = Date.now()
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key)
      }
    }
  }

  // è·å–ç¼“å­˜ç»Ÿè®¡
  getStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys()),
    }
  }
}

const frontendCache = new FrontendCache()

// å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
setInterval(() => frontendCache.cleanup(), 60000) // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡

export function useCache() {
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  const getCached = <T>(key: string): T | null => {
    return frontendCache.get<T>(key)
  }

  const setCached = <T>(key: string, data: T, ttl?: number): void => {
    frontendCache.set(key, data, ttl)
  }

  const deleteCached = (key: string): void => {
    frontendCache.delete(key)
  }

  const clearCache = (): void => {
    frontendCache.clear()
  }

  // å¸¦ç¼“å­˜çš„æ•°æ®è·å–
  const fetchWithCache = async <T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl?: number
  ): Promise<T> => {
    // å…ˆæ£€æŸ¥ç¼“å­˜
    const cached = getCached<T>(key)
    if (cached !== null) {
      return cached
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œè·å–
    isLoading.value = true
    error.value = null

    try {
      const data = await fetcher()
      setCached(key, data, ttl)
      return data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'è·å–æ•°æ®å¤±è´¥'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const cacheStats = computed(() => frontendCache.getStats())

  return {
    isLoading,
    error,
    getCached,
    setCached,
    deleteCached,
    clearCache,
    fetchWithCache,
    cacheStats,
  }
}
```

### APIç¼“å­˜æœåŠ¡

```typescript
// src/services/api-cache.ts
import { useCache } from '@/composables/useCache'
import { musicApi } from './music-api'

class ApiCacheService {
  private cache = useCache()

  // ç¼“å­˜æ­Œæ›²åˆ—è¡¨
  async getSongs(params: any = {}) {
    const cacheKey = `songs:${JSON.stringify(params)}`

    return this.cache.fetchWithCache(
      cacheKey,
      () => musicApi.getSongs(params),
      5 * 60 * 1000 // 5åˆ†é’Ÿç¼“å­˜
    )
  }

  // ç¼“å­˜æ­Œæ›²è¯¦æƒ…
  async getSong(id: string) {
    const cacheKey = `song:${id}`

    return this.cache.fetchWithCache(
      cacheKey,
      () => musicApi.getSong(id),
      30 * 60 * 1000 // 30åˆ†é’Ÿç¼“å­˜
    )
  }

  // ç¼“å­˜æœç´¢ç»“æœ
  async searchSongs(query: string) {
    const cacheKey = `search:${query}`

    return this.cache.fetchWithCache(
      cacheKey,
      () => musicApi.searchSongs(query),
      10 * 60 * 1000 // 10åˆ†é’Ÿç¼“å­˜
    )
  }

  // ç¼“å­˜ç”¨æˆ·æ­Œå•
  async getUserPlaylists(userId: string) {
    const cacheKey = `user:playlists:${userId}`

    return this.cache.fetchWithCache(
      cacheKey,
      () => musicApi.getUserPlaylists(userId),
      15 * 60 * 1000 // 15åˆ†é’Ÿç¼“å­˜
    )
  }

  // æ¸…é™¤ç‰¹å®šç±»å‹çš„ç¼“å­˜
  clearSongCache() {
    const stats = this.cache.cacheStats.value
    stats.keys.forEach(key => {
      if (key.startsWith('song:') || key.startsWith('songs:')) {
        this.cache.deleteCached(key)
      }
    })
  }

  clearUserCache(userId: string) {
    const stats = this.cache.cacheStats.value
    stats.keys.forEach(key => {
      if (key.includes(userId)) {
        this.cache.deleteCached(key)
      }
    })
  }

  clearSearchCache() {
    const stats = this.cache.cacheStats.value
    stats.keys.forEach(key => {
      if (key.startsWith('search:')) {
        this.cache.deleteCached(key)
      }
    })
  }
}

export const apiCacheService = new ApiCacheService()
```

---

## ğŸ“Š ç¼“å­˜ç›‘æ§å’Œä¼˜åŒ–

### ç¼“å­˜ç›‘æ§æœåŠ¡

```typescript
// src/cache/monitoring/cache-monitor.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { Cron, CronExpression } from '@nestjs/schedule'
import { CacheService } from '../cache.service'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'

@Injectable()
export class CacheMonitorService {
  private readonly logger = new Logger(CacheMonitorService.name)

  constructor(
    private readonly cacheService: CacheService,
    @InjectRedis() private readonly redis: Redis,
  ) {}

  /**
   * å®šæœŸç›‘æ§ç¼“å­˜æ€§èƒ½
   */
  @Cron(CronExpression.EVERY_5_MINUTES)
  async monitorCachePerformance() {
    try {
      const stats = this.cacheService.getStats()
      const info = await this.cacheService.getInfo()

      // è®°å½•å…³é”®æŒ‡æ ‡
      this.logger.log(`Cache Stats: Hit Rate: ${(stats.hitRate * 100).toFixed(2)}%, Hits: ${stats.hits}, Misses: ${stats.misses}`)

      // æ£€æŸ¥å‘½ä¸­ç‡
      if (stats.hitRate < 0.7) {
        this.logger.warn(`Low cache hit rate: ${(stats.hitRate * 100).toFixed(2)}%`)
      }

      // æ£€æŸ¥å†…å­˜ä½¿ç”¨
      const memoryInfo = await this.redis.info('memory')
      const usedMemory = this.extractMemoryUsage(memoryInfo)

      if (usedMemory > 1024 * 1024 * 1024) { // 1GB
        this.logger.warn(`High Redis memory usage: ${(usedMemory / 1024 / 1024).toFixed(2)}MB`)
      }

    } catch (error) {
      this.logger.error('Cache monitoring error:', error)
    }
  }

  /**
   * ç¼“å­˜é¢„çƒ­
   */
  @Cron(CronExpression.EVERY_HOUR)
  async warmupCache() {
    try {
      this.logger.log('Starting cache warmup...')

      // é¢„çƒ­çƒ­é—¨æ­Œæ›²
      await this.warmupPopularSongs()

      // é¢„çƒ­çƒ­é—¨æ­Œå•
      await this.warmupPopularPlaylists()

      // é¢„çƒ­ç”¨æˆ·æ•°æ®
      await this.warmupActiveUsers()

      this.logger.log('Cache warmup completed')
    } catch (error) {
      this.logger.error('Cache warmup error:', error)
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  @Cron(CronExpression.EVERY_30_MINUTES)
  async cleanupExpiredCache() {
    try {
      // æ¸…ç†è¿‡æœŸçš„æœç´¢ç¼“å­˜
      await this.cleanupSearchCache()

      // æ¸…ç†è¿‡æœŸçš„ä¸´æ—¶æ•°æ®
      await this.cleanupTempData()

      this.logger.log('Cache cleanup completed')
    } catch (error) {
      this.logger.error('Cache cleanup error:', error)
    }
  }

  /**
   * åˆ†æç¼“å­˜ä½¿ç”¨æ¨¡å¼
   */
  async analyzeCachePatterns() {
    try {
      const keys = await this.redis.keys('*')
      const patterns = new Map<string, number>()

      keys.forEach(key => {
        const pattern = key.split(':')[0]
        patterns.set(pattern, (patterns.get(pattern) || 0) + 1)
      })

      const sortedPatterns = Array.from(patterns.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)

      this.logger.log('Top cache patterns:', sortedPatterns)

      return sortedPatterns
    } catch (error) {
      this.logger.error('Cache pattern analysis error:', error)
      return []
    }
  }

  /**
   * è·å–ç¼“å­˜å¥åº·çŠ¶æ€
   */
  async getCacheHealth() {
    try {
      const stats = this.cacheService.getStats()
      const info = await this.redis.info()
      const keyCount = await this.redis.dbsize()

      return {
        status: stats.hitRate > 0.7 ? 'healthy' : 'warning',
        hitRate: stats.hitRate,
        keyCount,
        memoryUsage: this.extractMemoryUsage(info),
        uptime: this.extractUptime(info),
        connectedClients: this.extractConnectedClients(info),
      }
    } catch (error) {
      this.logger.error('Get cache health error:', error)
      return {
        status: 'error',
        error: error.message,
      }
    }
  }

  private async warmupPopularSongs() {
    // å®ç°çƒ­é—¨æ­Œæ›²é¢„çƒ­é€»è¾‘
    const cacheKey = 'songs:popular:50'
    const exists = await this.cacheService.exists(cacheKey)

    if (!exists) {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æœåŠ¡æ¥è·å–æ•°æ®
      // await this.songsService.getPopularSongs(50)
    }
  }

  private async warmupPopularPlaylists() {
    // å®ç°çƒ­é—¨æ­Œå•é¢„çƒ­é€»è¾‘
    const cacheKey = 'playlists:popular:20'
    const exists = await this.cacheService.exists(cacheKey)

    if (!exists) {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æœåŠ¡æ¥è·å–æ•°æ®
      // await this.playlistsService.getPopularPlaylists(20)
    }
  }

  private async warmupActiveUsers() {
    // å®ç°æ´»è·ƒç”¨æˆ·é¢„çƒ­é€»è¾‘
    // å¯ä»¥æ ¹æ®æœ€è¿‘ç™»å½•çš„ç”¨æˆ·æ¥é¢„çƒ­ä»–ä»¬çš„æ•°æ®
  }

  private async cleanupSearchCache() {
    const pattern = 'songs:search:*'
    const keys = await this.redis.keys(pattern)

    // åˆ é™¤è¶…è¿‡1å°æ—¶çš„æœç´¢ç¼“å­˜
    const cutoffTime = Date.now() - 60 * 60 * 1000

    for (const key of keys) {
      const ttl = await this.redis.ttl(key)
      if (ttl > 0 && ttl < cutoffTime / 1000) {
        await this.redis.del(key)
      }
    }
  }

  private async cleanupTempData() {
    const patterns = ['temp:*', 'lock:*', 'session:*']

    for (const pattern of patterns) {
      const keys = await this.redis.keys(pattern)

      for (const key of keys) {
        const ttl = await this.redis.ttl(key)
        if (ttl === -1) { // æ²¡æœ‰è¿‡æœŸæ—¶é—´çš„é”®
          await this.redis.expire(key, 3600) // è®¾ç½®1å°æ—¶è¿‡æœŸ
        }
      }
    }
  }

  private extractMemoryUsage(info: string): number {
    const match = info.match(/used_memory:(\d+)/)
    return match ? parseInt(match[1]) : 0
  }

  private extractUptime(info: string): number {
    const match = info.match(/uptime_in_seconds:(\d+)/)
    return match ? parseInt(match[1]) : 0
  }

  private extractConnectedClients(info: string): number {
    const match = info.match(/connected_clients:(\d+)/)
    return match ? parseInt(match[1]) : 0
  }
}
```

### ç¼“å­˜æ€§èƒ½åˆ†æ

```typescript
// src/cache/analysis/cache-analyzer.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { CacheService } from '../cache.service'

interface CacheAnalysis {
  hotKeys: Array<{ key: string; accessCount: number }>
  coldKeys: Array<{ key: string; lastAccess: number }>
  memoryDistribution: Record<string, number>
  recommendations: string[]
}

@Injectable()
export class CacheAnalyzerService {
  private readonly logger = new Logger(CacheAnalyzerService.name)
  private accessCounts = new Map<string, number>()
  private lastAccess = new Map<string, number>()

  constructor(private readonly cacheService: CacheService) {}

  /**
   * è®°å½•ç¼“å­˜è®¿é—®
   */
  recordAccess(key: string) {
    this.accessCounts.set(key, (this.accessCounts.get(key) || 0) + 1)
    this.lastAccess.set(key, Date.now())
  }

  /**
   * åˆ†æç¼“å­˜ä½¿ç”¨æƒ…å†µ
   */
  async analyzeCacheUsage(): Promise<CacheAnalysis> {
    const hotKeys = this.getHotKeys()
    const coldKeys = this.getColdKeys()
    const memoryDistribution = await this.getMemoryDistribution()
    const recommendations = this.generateRecommendations(hotKeys, coldKeys)

    return {
      hotKeys,
      coldKeys,
      memoryDistribution,
      recommendations,
    }
  }

  /**
   * è·å–çƒ­ç‚¹é”®
   */
  private getHotKeys(): Array<{ key: string; accessCount: number }> {
    return Array.from(this.accessCounts.entries())
      .map(([key, count]) => ({ key, accessCount: count }))
      .sort((a, b) => b.accessCount - a.accessCount)
      .slice(0, 20)
  }

  /**
   * è·å–å†·é”®
   */
  private getColdKeys(): Array<{ key: string; lastAccess: number }> {
    const now = Date.now()
    const oneHourAgo = now - 60 * 60 * 1000

    return Array.from(this.lastAccess.entries())
      .filter(([, lastAccess]) => lastAccess < oneHourAgo)
      .map(([key, lastAccess]) => ({ key, lastAccess }))
      .sort((a, b) => a.lastAccess - b.lastAccess)
      .slice(0, 20)
  }

  /**
   * è·å–å†…å­˜åˆ†å¸ƒ
   */
  private async getMemoryDistribution(): Promise<Record<string, number>> {
    // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„å†…å­˜åˆ†å¸ƒåˆ†æ
    // å¯ä»¥é€šè¿‡Redisçš„MEMORY USAGEå‘½ä»¤æ¥è·å–æ¯ä¸ªé”®çš„å†…å­˜ä½¿ç”¨æƒ…å†µ
    return {
      'user:*': 1024 * 1024, // 1MB
      'song:*': 2048 * 1024, // 2MB
      'playlist:*': 512 * 1024, // 512KB
      'search:*': 256 * 1024, // 256KB
    }
  }

  /**
   * ç”Ÿæˆä¼˜åŒ–å»ºè®®
   */
  private generateRecommendations(
    hotKeys: Array<{ key: string; accessCount: number }>,
    coldKeys: Array<{ key: string; lastAccess: number }>
  ): string[] {
    const recommendations = []

    // çƒ­ç‚¹é”®å»ºè®®
    if (hotKeys.length > 0) {
      const topHotKey = hotKeys[0]
      if (topHotKey.accessCount > 1000) {
        recommendations.push(`è€ƒè™‘ä¸ºçƒ­ç‚¹é”® ${topHotKey.key} å¢åŠ TTLæˆ–ä½¿ç”¨å†…å­˜ç¼“å­˜`)
      }
    }

    // å†·é”®å»ºè®®
    if (coldKeys.length > 10) {
      recommendations.push(`å‘ç° ${coldKeys.length} ä¸ªå†·é”®ï¼Œå»ºè®®æ¸…ç†ä»¥é‡Šæ”¾å†…å­˜`)
    }

    // é€šç”¨å»ºè®®
    const stats = this.cacheService.getStats()
    if (stats.hitRate < 0.8) {
      recommendations.push('ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½ï¼Œå»ºè®®ä¼˜åŒ–ç¼“å­˜ç­–ç•¥')
    }

    return recommendations
  }

  /**
   * é‡ç½®åˆ†ææ•°æ®
   */
  resetAnalysis() {
    this.accessCounts.clear()
    this.lastAccess.clear()
  }
}
```

---

## ğŸ§ª ç¼“å­˜æµ‹è¯•

### ç¼“å­˜å•å…ƒæµ‹è¯•

```typescript
// src/cache/cache.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing'
import { CacheService } from './cache.service'
import { ConfigService } from '@nestjs/config'
import { getRedisToken } from '@nestjs-modules/ioredis'

describe('CacheService', () => {
  let service: CacheService
  let redis: any

  beforeEach(async () => {
    const mockRedis = {
      get: jest.fn(),
      set: jest.fn(),
      setex: jest.fn(),
      del: jest.fn(),
      exists: jest.fn(),
      expire: jest.fn(),
      ttl: jest.fn(),
      mget: jest.fn(),
      pipeline: jest.fn(() => ({
        setex: jest.fn(),
        exec: jest.fn(),
      })),
    }

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CacheService,
        {
          provide: getRedisToken(),
          useValue: mockRedis,
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn((key: string) => {
              const config = {
                'cache.memory.maxSize': 100,
                'cache.memory.ttl': 300,
              }
              return config[key]
            }),
          },
        },
      ],
    }).compile()

    service = module.get<CacheService>(CacheService)
    redis = module.get(getRedisToken())
  })

  describe('get', () => {
    it('should return cached data from Redis', async () => {
      const testData = { id: 1, name: 'test' }
      redis.get.mockResolvedValue(JSON.stringify(testData))

      const result = await service.get('test-key')

      expect(result).toEqual(testData)
      expect(redis.get).toHaveBeenCalledWith('test-key')
    })

    it('should return null for non-existent key', async () => {
      redis.get.mockResolvedValue(null)

      const result = await service.get('non-existent-key')

      expect(result).toBeNull()
    })
  })

  describe('set', () => {
    it('should set data in Redis with TTL', async () => {
      const testData = { id: 1, name: 'test' }
      redis.setex.mockResolvedValue('OK')

      await service.set('test-key', testData, { ttl: 3600 })

      expect(redis.setex).toHaveBeenCalledWith(
        'test-key',
        3600,
        JSON.stringify(testData)
      )
    })
  })

  describe('getOrSet', () => {
    it('should return cached data if exists', async () => {
      const testData = { id: 1, name: 'test' }
      redis.get.mockResolvedValue(JSON.stringify(testData))

      const factory = jest.fn()
      const result = await service.getOrSet('test-key', factory)

      expect(result).toEqual(testData)
      expect(factory).not.toHaveBeenCalled()
    })

    it('should call factory and cache result if not exists', async () => {
      const testData = { id: 1, name: 'test' }
      redis.get.mockResolvedValue(null)
      redis.set.mockResolvedValue('OK')

      const factory = jest.fn().mockResolvedValue(testData)
      const result = await service.getOrSet('test-key', factory)

      expect(result).toEqual(testData)
      expect(factory).toHaveBeenCalled()
    })
  })
})
```

---

## ğŸ”§ æ•…éšœæ’é™¤

### å¸¸è§ç¼“å­˜é—®é¢˜

1. **ç¼“å­˜ç©¿é€**
   ```typescript
   // ä½¿ç”¨ç©ºå€¼ç¼“å­˜é˜²æ­¢ç¼“å­˜ç©¿é€
   async getUser(id: string) {
     const cacheKey = `user:${id}`
     let user = await this.cacheService.get(cacheKey)

     if (user === null) {
       user = await this.userRepository.findOne({ where: { id } })

       // å³ä½¿ç”¨æˆ·ä¸å­˜åœ¨ä¹Ÿç¼“å­˜ç©ºå€¼ï¼Œé˜²æ­¢é‡å¤æŸ¥è¯¢
       await this.cacheService.set(cacheKey, user || 'NULL', { ttl: 300 })
     }

     return user === 'NULL' ? null : user
   }
   ```

2. **ç¼“å­˜é›ªå´©**
   ```typescript
   // ä½¿ç”¨éšæœºTTLé˜²æ­¢ç¼“å­˜é›ªå´©
   const randomTTL = (baseTTL: number) => {
     const variance = baseTTL * 0.1 // 10%çš„éšæœºå˜åŒ–
     return baseTTL + Math.random() * variance * 2 - variance
   }

   await this.cacheService.set(key, data, { ttl: randomTTL(3600) })
   ```

3. **ç¼“å­˜å‡»ç©¿**
   ```typescript
   // ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢ç¼“å­˜å‡»ç©¿
   async getPopularData() {
     const cacheKey = 'popular:data'
     const lockKey = `lock:${cacheKey}`

     return this.cacheService.getOrSet(
       cacheKey,
       async () => {
         // è¿™é‡Œä¼šè‡ªåŠ¨å¤„ç†åˆ†å¸ƒå¼é”
         return this.fetchPopularDataFromDB()
       },
       { ttl: 3600 }
     )
   }
   ```

### æ€§èƒ½è°ƒä¼˜å»ºè®®

1. **åˆç†è®¾ç½®TTL**
   - çƒ­ç‚¹æ•°æ®ï¼šè¾ƒé•¿TTLï¼ˆ1-2å°æ—¶ï¼‰
   - å®æ—¶æ•°æ®ï¼šè¾ƒçŸ­TTLï¼ˆ5-15åˆ†é’Ÿï¼‰
   - ç”¨æˆ·æ•°æ®ï¼šä¸­ç­‰TTLï¼ˆ30-60åˆ†é’Ÿï¼‰

2. **ç¼“å­˜é”®è®¾è®¡**
   - ä½¿ç”¨æœ‰æ„ä¹‰çš„å‰ç¼€
   - é¿å…é”®åå†²çª
   - è€ƒè™‘é”®çš„å±‚æ¬¡ç»“æ„

3. **å†…å­˜ä¼˜åŒ–**
   - å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
   - ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ
   - ä½¿ç”¨å‹ç¼©å­˜å‚¨å¤§å¯¹è±¡

---

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å¤šå±‚ç¼“å­˜æ¶æ„çš„è®¾è®¡å’Œå®ç°ï¼ŒåŒ…æ‹¬Redisåˆ†å¸ƒå¼ç¼“å­˜ã€åº”ç”¨å†…å­˜ç¼“å­˜å’Œå‰ç«¯ç¼“å­˜ç­–ç•¥ã€‚*
```
```
