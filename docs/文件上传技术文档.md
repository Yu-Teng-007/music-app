# ğŸ“¤ æ–‡ä»¶ä¸Šä¼ æŠ€æœ¯æ–‡æ¡£

**æŠ€æœ¯æ ˆ**: NestJS + Multer + Sharp + FFmpeg  
**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-06-27

---

## ğŸ“‹ æ–‡ä»¶ä¸Šä¼ æ¦‚è§ˆ

æ–‡ä»¶ä¸Šä¼ ç³»ç»Ÿæ”¯æŒéŸ³é¢‘æ–‡ä»¶å’Œå›¾ç‰‡æ–‡ä»¶çš„ä¸Šä¼ å¤„ç†ï¼ŒåŒ…æ‹¬æ ¼å¼éªŒè¯ã€å¤§å°é™åˆ¶ã€æ–‡ä»¶è½¬æ¢ã€ç¼©ç•¥å›¾ç”Ÿæˆç­‰åŠŸèƒ½ã€‚ç³»ç»Ÿé‡‡ç”¨æµå¼å¤„ç†å’Œå¼‚æ­¥é˜Ÿåˆ—ï¼Œç¡®ä¿é«˜æ€§èƒ½å’Œç¨³å®šæ€§ã€‚

### ğŸ—ï¸ æ–‡ä»¶ä¸Šä¼ æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯ä¸Šä¼       â”‚    â”‚   ä¸Šä¼ ä¸­é—´ä»¶    â”‚    â”‚   æ–‡ä»¶å¤„ç†å™¨    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ æ–‡ä»¶é€‰æ‹©      â”‚â”€â”€â”€â–ºâ”‚ â€¢ æ ¼å¼éªŒè¯      â”‚â”€â”€â”€â–ºâ”‚ â€¢ éŸ³é¢‘è½¬ç       â”‚
â”‚ â€¢ è¿›åº¦æ˜¾ç¤º      â”‚    â”‚ â€¢ å¤§å°æ£€æŸ¥      â”‚    â”‚ â€¢ å›¾ç‰‡å‹ç¼©      â”‚
â”‚ â€¢ é”™è¯¯å¤„ç†      â”‚    â”‚ â€¢ ä¸´æ—¶å­˜å‚¨      â”‚    â”‚ â€¢ ç¼©ç•¥å›¾ç”Ÿæˆ    â”‚
â”‚ â€¢ æ–­ç‚¹ç»­ä¼       â”‚    â”‚ â€¢ ç—…æ¯’æ‰«æ      â”‚    â”‚ â€¢ å…ƒæ•°æ®æå–    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å­˜å‚¨ç®¡ç†      â”‚    â”‚   æ•°æ®åº“è®°å½•    â”‚    â”‚   CDNåˆ†å‘       â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ æœ¬åœ°å­˜å‚¨      â”‚    â”‚ â€¢ æ–‡ä»¶ä¿¡æ¯      â”‚    â”‚ â€¢ é™æ€èµ„æº      â”‚
â”‚ â€¢ äº‘å­˜å‚¨       â”‚    â”‚ â€¢ å…³è”å…³ç³»      â”‚    â”‚ â€¢ ç¼“å­˜ç­–ç•¥      â”‚
â”‚ â€¢ å¤‡ä»½ç­–ç•¥      â”‚    â”‚ â€¢ è®¿é—®æƒé™      â”‚    â”‚ â€¢ å…¨çƒåŠ é€Ÿ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æœåŠ¡ç«¯é…ç½®

### ä¸Šä¼ æ¨¡å—é…ç½®

```typescript
// src/upload/upload.module.ts
import { Module } from '@nestjs/common'
import { MulterModule } from '@nestjs/platform-express'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { UploadController } from './upload.controller'
import { UploadService } from './upload.service'
import { FileProcessorService } from './file-processor.service'
import { StorageService } from './storage.service'

@Module({
  imports: [
    MulterModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        dest: configService.get<string>('upload.tempDir') || './temp',
        limits: {
          fileSize: configService.get<number>('upload.maxFileSize') || 50 * 1024 * 1024, // 50MB
          files: 5, // æœ€å¤š5ä¸ªæ–‡ä»¶
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [UploadController],
  providers: [UploadService, FileProcessorService, StorageService],
  exports: [UploadService],
})
export class UploadModule {}
```

### æ–‡ä»¶ä¸Šä¼ é…ç½®

```typescript
// src/config/upload.config.ts
import { registerAs } from '@nestjs/config'

export default registerAs('upload', () => ({
  // åŸºç¡€é…ç½®
  tempDir: process.env.UPLOAD_TEMP_DIR || './temp',
  uploadDir: process.env.UPLOAD_DIR || './uploads',
  maxFileSize: parseInt(process.env.MAX_FILE_SIZE || '52428800'), // 50MB
  
  // éŸ³é¢‘é…ç½®
  audio: {
    allowedFormats: ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac'],
    maxDuration: 600, // 10åˆ†é’Ÿ
    outputFormat: 'mp3',
    bitrate: '320k',
  },
  
  // å›¾ç‰‡é…ç½®
  image: {
    allowedFormats: ['jpg', 'jpeg', 'png', 'webp', 'gif'],
    maxWidth: 2048,
    maxHeight: 2048,
    quality: 85,
    thumbnailSizes: [150, 300, 600],
  },
  
  // å­˜å‚¨é…ç½®
  storage: {
    type: process.env.STORAGE_TYPE || 'local', // 'local' | 'aws' | 'aliyun'
    aws: {
      bucket: process.env.AWS_S3_BUCKET,
      region: process.env.AWS_REGION,
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    },
    aliyun: {
      bucket: process.env.ALIYUN_OSS_BUCKET,
      region: process.env.ALIYUN_OSS_REGION,
      accessKeyId: process.env.ALIYUN_ACCESS_KEY_ID,
      accessKeySecret: process.env.ALIYUN_ACCESS_KEY_SECRET,
    },
  },
}))
```

---

## ğŸ“ æ–‡ä»¶ä¸Šä¼ æ§åˆ¶å™¨

### ä¸Šä¼ æ§åˆ¶å™¨å®ç°

```typescript
// src/upload/upload.controller.ts
import {
  Controller,
  Post,
  UseInterceptors,
  UploadedFile,
  UploadedFiles,
  Body,
  UseGuards,
  Request,
  BadRequestException,
  PayloadTooLargeException,
} from '@nestjs/common'
import {
  FileInterceptor,
  FilesInterceptor,
  FileFieldsInterceptor,
} from '@nestjs/platform-express'
import {
  ApiTags,
  ApiOperation,
  ApiConsumes,
  ApiBody,
  ApiBearerAuth,
  ApiResponse,
} from '@nestjs/swagger'
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard'
import { UploadService } from './upload.service'
import { FileValidationPipe } from './pipes/file-validation.pipe'
import { UploadAudioDto, UploadImageDto } from './dto/upload.dto'

@ApiTags('upload')
@Controller('upload')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth('JWT-auth')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post('audio')
  @ApiOperation({ summary: 'ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    description: 'éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ ',
    type: UploadAudioDto,
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadAudio(
    @UploadedFile(new FileValidationPipe('audio')) file: Express.Multer.File,
    @Body() uploadAudioDto: UploadAudioDto,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processAudioFile(
        file,
        uploadAudioDto,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: 'éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ æˆåŠŸ',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('image')
  @ApiOperation({ summary: 'ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    description: 'å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ ',
    type: UploadImageDto,
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadImage(
    @UploadedFile(new FileValidationPipe('image')) file: Express.Multer.File,
    @Body() uploadImageDto: UploadImageDto,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processImageFile(
        file,
        uploadImageDto,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: 'å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ æˆåŠŸ',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('multiple')
  @ApiOperation({ summary: 'æ‰¹é‡ä¸Šä¼ æ–‡ä»¶' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FilesInterceptor('files', 10)) // æœ€å¤š10ä¸ªæ–‡ä»¶
  async uploadMultiple(
    @UploadedFiles(new FileValidationPipe('mixed')) files: Express.Multer.File[],
    @Request() req: any,
  ) {
    try {
      const results = await this.uploadService.processMultipleFiles(
        files,
        req.user.id,
      )
      
      return {
        success: true,
        data: results,
        message: `æˆåŠŸä¸Šä¼  ${results.length} ä¸ªæ–‡ä»¶`,
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('avatar')
  @ApiOperation({ summary: 'ä¸Šä¼ ç”¨æˆ·å¤´åƒ' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FileInterceptor('avatar'))
  async uploadAvatar(
    @UploadedFile(new FileValidationPipe('avatar')) file: Express.Multer.File,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processAvatarFile(
        file,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: 'å¤´åƒä¸Šä¼ æˆåŠŸ',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('cover')
  @ApiOperation({ summary: 'ä¸Šä¼ å°é¢å›¾ç‰‡' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FileInterceptor('cover'))
  async uploadCover(
    @UploadedFile(new FileValidationPipe('cover')) file: Express.Multer.File,
    @Body() body: { type: 'song' | 'playlist' | 'album' },
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processCoverFile(
        file,
        body.type,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: 'å°é¢å›¾ç‰‡ä¸Šä¼ æˆåŠŸ',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }
}
```

---

## ğŸµ æ–‡ä»¶å¤„ç†å™¨æœåŠ¡

### éŸ³é¢‘å¤„ç†å®ç°

```typescript
// src/upload/file-processor.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as ffmpeg from 'fluent-ffmpeg'
import * as sharp from 'sharp'
import * as path from 'path'
import * as fs from 'fs/promises'
import { promisify } from 'util'

@Injectable()
export class FileProcessorService {
  private readonly logger = new Logger(FileProcessorService.name)

  constructor(private readonly configService: ConfigService) {}

  /**
   * æå–éŸ³é¢‘å…ƒæ•°æ®
   */
  async extractAudioMetadata(filePath: string): Promise<any> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(filePath, (err, metadata) => {
        if (err) {
          this.logger.error('Failed to extract audio metadata:', err)
          reject(new Error('æ— æ³•è¯»å–éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯'))
          return
        }

        const format = metadata.format
        const audioStream = metadata.streams.find(s => s.codec_type === 'audio')

        resolve({
          duration: format.duration,
          bitrate: format.bit_rate,
          size: format.size,
          title: format.tags?.title,
          artist: format.tags?.artist,
          album: format.tags?.album,
          genre: format.tags?.genre,
          year: format.tags?.date ? parseInt(format.tags.date) : null,
          codec: audioStream?.codec_name,
          sampleRate: audioStream?.sample_rate,
          channels: audioStream?.channels,
        })
      })
    })
  }

  /**
   * è½¬æ¢éŸ³é¢‘æ ¼å¼
   */
  async convertAudio(inputPath: string, outputFormat: string): Promise<{
    path: string
    size: number
  }> {
    const outputPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_converted.${outputFormat}`
    )

    const bitrate = this.configService.get<string>('upload.audio.bitrate')

    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .audioCodec('libmp3lame')
        .audioBitrate(bitrate)
        .format(outputFormat)
        .output(outputPath)
        .on('end', async () => {
          try {
            const stats = await fs.stat(outputPath)
            resolve({
              path: outputPath,
              size: stats.size,
            })
          } catch (error) {
            reject(error)
          }
        })
        .on('error', (err) => {
          this.logger.error('Audio conversion failed:', err)
          reject(new Error('éŸ³é¢‘è½¬æ¢å¤±è´¥'))
        })
        .run()
    })
  }

  /**
   * æå–æˆ–ç”Ÿæˆå°é¢å›¾ç‰‡
   */
  async extractOrGenerateCover(audioPath: string, metadata: any): Promise<string> {
    const coverPath = path.join(
      path.dirname(audioPath),
      `${path.parse(audioPath).name}_cover.jpg`
    )

    try {
      // å°è¯•ä»éŸ³é¢‘æ–‡ä»¶ä¸­æå–å°é¢
      await this.extractCoverFromAudio(audioPath, coverPath)
      return coverPath
    } catch (error) {
      // å¦‚æœæå–å¤±è´¥ï¼Œç”Ÿæˆé»˜è®¤å°é¢
      return this.generateDefaultCover(coverPath, metadata)
    }
  }

  /**
   * ä»éŸ³é¢‘æ–‡ä»¶æå–å°é¢
   */
  private async extractCoverFromAudio(audioPath: string, outputPath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      ffmpeg(audioPath)
        .outputOptions(['-an', '-vcodec', 'copy'])
        .output(outputPath)
        .on('end', () => resolve())
        .on('error', (err) => reject(err))
        .run()
    })
  }

  /**
   * ç”Ÿæˆé»˜è®¤å°é¢
   */
  private async generateDefaultCover(outputPath: string, metadata: any): Promise<string> {
    const width = 600
    const height = 600

    // åˆ›å»ºä¸€ä¸ªç®€å•çš„é»˜è®¤å°é¢
    await sharp({
      create: {
        width,
        height,
        channels: 3,
        background: { r: 100, g: 100, b: 100 }
      }
    })
    .jpeg({ quality: 90 })
    .toFile(outputPath)

    return outputPath
  }

  /**
   * å¤„ç†å›¾ç‰‡æ–‡ä»¶
   */
  async processImage(
    inputPath: string,
    type: 'avatar' | 'cover' | 'general'
  ): Promise<Array<{ path: string; size?: number }>> {
    const results = []
    const maxWidth = this.configService.get<number>('upload.image.maxWidth')
    const maxHeight = this.configService.get<number>('upload.image.maxHeight')
    const quality = this.configService.get<number>('upload.image.quality')

    // å¤„ç†åŸå›¾
    const originalPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_processed.jpg`
    )

    await sharp(inputPath)
      .resize(maxWidth, maxHeight, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality })
      .toFile(originalPath)

    results.push({ path: originalPath })

    // æ ¹æ®ç±»å‹ç”Ÿæˆç¼©ç•¥å›¾
    if (type === 'avatar') {
      const sizes = [150, 300]
      for (const size of sizes) {
        const thumbnailPath = path.join(
          path.dirname(inputPath),
          `${path.parse(inputPath).name}_${size}x${size}.jpg`
        )

        await sharp(inputPath)
          .resize(size, size, { fit: 'cover' })
          .jpeg({ quality: 80 })
          .toFile(thumbnailPath)

        results.push({ path: thumbnailPath, size })
      }
    } else if (type === 'cover') {
      const sizes = [300, 600]
      for (const size of sizes) {
        const thumbnailPath = path.join(
          path.dirname(inputPath),
          `${path.parse(inputPath).name}_${size}x${size}.jpg`
        )

        await sharp(inputPath)
          .resize(size, size, { fit: 'cover' })
          .jpeg({ quality: 85 })
          .toFile(thumbnailPath)

        results.push({ path: thumbnailPath, size })
      }
    }

    return results
  }

  /**
   * ç”Ÿæˆå›¾ç‰‡ç¼©ç•¥å›¾
   */
  async generateThumbnails(
    inputPath: string,
    sizes: number[]
  ): Promise<Array<{ path: string; size: number }>> {
    const results = []

    for (const size of sizes) {
      const thumbnailPath = path.join(
        path.dirname(inputPath),
        `${path.parse(inputPath).name}_thumb_${size}.jpg`
      )

      await sharp(inputPath)
        .resize(size, size, {
          fit: 'cover',
          position: 'center'
        })
        .jpeg({ quality: 80 })
        .toFile(thumbnailPath)

      results.push({ path: thumbnailPath, size })
    }

    return results
  }

  /**
   * å‹ç¼©å›¾ç‰‡
   */
  async compressImage(
    inputPath: string,
    quality: number = 85
  ): Promise<{ path: string; originalSize: number; compressedSize: number }> {
    const outputPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_compressed.jpg`
    )

    const originalStats = await fs.stat(inputPath)

    await sharp(inputPath)
      .jpeg({ quality, progressive: true })
      .toFile(outputPath)

    const compressedStats = await fs.stat(outputPath)

    return {
      path: outputPath,
      originalSize: originalStats.size,
      compressedSize: compressedStats.size,
    }
  }

  /**
   * è·å–å›¾ç‰‡ä¿¡æ¯
   */
  async getImageInfo(filePath: string): Promise<{
    width: number
    height: number
    format: string
    size: number
  }> {
    const metadata = await sharp(filePath).metadata()
    const stats = await fs.stat(filePath)

    return {
      width: metadata.width,
      height: metadata.height,
      format: metadata.format,
      size: stats.size,
    }
  }

  /**
   * éªŒè¯éŸ³é¢‘æ–‡ä»¶å®Œæ•´æ€§
   */
  async validateAudioFile(filePath: string): Promise<boolean> {
    try {
      const metadata = await this.extractAudioMetadata(filePath)
      return metadata.duration > 0
    } catch (error) {
      return false
    }
  }

  /**
   * éªŒè¯å›¾ç‰‡æ–‡ä»¶å®Œæ•´æ€§
   */
  async validateImageFile(filePath: string): Promise<boolean> {
    try {
      const metadata = await sharp(filePath).metadata()
      return metadata.width > 0 && metadata.height > 0
    } catch (error) {
      return false
    }
  }
}
```

---

## ğŸ’¾ å­˜å‚¨æœåŠ¡

### å¤šå­˜å‚¨åç«¯æ”¯æŒ

```typescript
// src/upload/storage.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as path from 'path'
import * as fs from 'fs/promises'
import { v4 as uuidv4 } from 'uuid'

interface StorageProvider {
  uploadFile(filePath: string, category: string): Promise<string>
  deleteFile(fileUrl: string): Promise<void>
  getFileUrl(key: string): string
}

@Injectable()
export class StorageService {
  private readonly logger = new Logger(StorageService.name)
  private provider: StorageProvider

  constructor(private readonly configService: ConfigService) {
    this.initializeProvider()
  }

  private initializeProvider() {
    const storageType = this.configService.get<string>('upload.storage.type')

    switch (storageType) {
      case 'aws':
        this.provider = new AWSStorageProvider(this.configService)
        break
      case 'aliyun':
        this.provider = new AliyunStorageProvider(this.configService)
        break
      default:
        this.provider = new LocalStorageProvider(this.configService)
    }

    this.logger.log(`Initialized ${storageType} storage provider`)
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    return this.provider.uploadFile(filePath, category)
  }

  async deleteFile(fileUrl: string): Promise<void> {
    return this.provider.deleteFile(fileUrl)
  }

  getFileUrl(key: string): string {
    return this.provider.getFileUrl(key)
  }
}

/**
 * æœ¬åœ°å­˜å‚¨æä¾›è€…
 */
class LocalStorageProvider implements StorageProvider {
  private readonly uploadDir: string

  constructor(private readonly configService: ConfigService) {
    this.uploadDir = this.configService.get<string>('upload.uploadDir')
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    const fileName = `${uuidv4()}${path.extname(filePath)}`
    const categoryDir = path.join(this.uploadDir, category)
    const targetPath = path.join(categoryDir, fileName)

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    await fs.mkdir(categoryDir, { recursive: true })

    // å¤åˆ¶æ–‡ä»¶
    await fs.copyFile(filePath, targetPath)

    // è¿”å›ç›¸å¯¹URL
    return `/uploads/${category}/${fileName}`
  }

  async deleteFile(fileUrl: string): Promise<void> {
    const filePath = path.join(process.cwd(), 'public', fileUrl)
    try {
      await fs.unlink(filePath)
    } catch (error) {
      // æ–‡ä»¶å¯èƒ½å·²ç»ä¸å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
    }
  }

  getFileUrl(key: string): string {
    return key // æœ¬åœ°å­˜å‚¨ç›´æ¥è¿”å›ç›¸å¯¹è·¯å¾„
  }
}

/**
 * AWS S3å­˜å‚¨æä¾›è€…
 */
class AWSStorageProvider implements StorageProvider {
  private s3Client: any

  constructor(private readonly configService: ConfigService) {
    // è¿™é‡Œåº”è¯¥åˆå§‹åŒ–AWS S3å®¢æˆ·ç«¯
    // const AWS = require('aws-sdk')
    // this.s3Client = new AWS.S3({...})
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    // AWS S3ä¸Šä¼ å®ç°
    throw new Error('AWS S3 provider not implemented')
  }

  async deleteFile(fileUrl: string): Promise<void> {
    // AWS S3åˆ é™¤å®ç°
    throw new Error('AWS S3 provider not implemented')
  }

  getFileUrl(key: string): string {
    // è¿”å›S3 URL
    return key
  }
}

/**
 * é˜¿é‡Œäº‘OSSå­˜å‚¨æä¾›è€…
 */
class AliyunStorageProvider implements StorageProvider {
  private ossClient: any

  constructor(private readonly configService: ConfigService) {
    // è¿™é‡Œåº”è¯¥åˆå§‹åŒ–é˜¿é‡Œäº‘OSSå®¢æˆ·ç«¯
    // const OSS = require('ali-oss')
    // this.ossClient = new OSS({...})
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    // é˜¿é‡Œäº‘OSSä¸Šä¼ å®ç°
    throw new Error('Aliyun OSS provider not implemented')
  }

  async deleteFile(fileUrl: string): Promise<void> {
    // é˜¿é‡Œäº‘OSSåˆ é™¤å®ç°
    throw new Error('Aliyun OSS provider not implemented')
  }

  getFileUrl(key: string): string {
    // è¿”å›OSS URL
    return key
  }
}
```

---

## ğŸ” æ–‡ä»¶éªŒè¯ç®¡é“

### æ–‡ä»¶éªŒè¯å®ç°

```typescript
// src/upload/pipes/file-validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as path from 'path'
import * as fileType from 'file-type'
import * as fs from 'fs'

@Injectable()
export class FileValidationPipe implements PipeTransform {
  constructor(
    private readonly fileCategory: 'audio' | 'image' | 'avatar' | 'cover' | 'mixed',
    private readonly configService?: ConfigService,
  ) {}

  async transform(value: Express.Multer.File | Express.Multer.File[], metadata: ArgumentMetadata) {
    if (!value) {
      throw new BadRequestException('æ–‡ä»¶ä¸èƒ½ä¸ºç©º')
    }

    const files = Array.isArray(value) ? value : [value]

    for (const file of files) {
      await this.validateFile(file)
    }

    return value
  }

  private async validateFile(file: Express.Multer.File) {
    // 1. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if (!file || !file.path) {
      throw new BadRequestException('æ–‡ä»¶ä¸Šä¼ å¤±è´¥')
    }

    // 2. æ£€æŸ¥æ–‡ä»¶å¤§å°
    this.validateFileSize(file)

    // 3. æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
    this.validateFileExtension(file)

    // 4. æ£€æŸ¥æ–‡ä»¶MIMEç±»å‹
    await this.validateFileMimeType(file)

    // 5. æ£€æŸ¥æ–‡ä»¶å†…å®¹ï¼ˆé­”æ•°éªŒè¯ï¼‰
    await this.validateFileContent(file)
  }

  private validateFileSize(file: Express.Multer.File) {
    const maxSize = this.getMaxFileSize()

    if (file.size > maxSize) {
      throw new BadRequestException(
        `æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ï¼Œæœ€å¤§å…è®¸ ${Math.round(maxSize / 1024 / 1024)}MB`
      )
    }

    if (file.size === 0) {
      throw new BadRequestException('æ–‡ä»¶å†…å®¹ä¸ºç©º')
    }
  }

  private validateFileExtension(file: Express.Multer.File) {
    const allowedExtensions = this.getAllowedExtensions()
    const fileExtension = path.extname(file.originalname).toLowerCase().slice(1)

    if (!allowedExtensions.includes(fileExtension)) {
      throw new BadRequestException(
        `ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ .${fileExtension}ï¼Œæ”¯æŒçš„æ ¼å¼: ${allowedExtensions.join(', ')}`
      )
    }
  }

  private async validateFileMimeType(file: Express.Multer.File) {
    const allowedMimeTypes = this.getAllowedMimeTypes()

    if (!allowedMimeTypes.includes(file.mimetype)) {
      throw new BadRequestException(
        `ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ ${file.mimetype}`
      )
    }
  }

  private async validateFileContent(file: Express.Multer.File) {
    try {
      // è¯»å–æ–‡ä»¶å¤´éƒ¨å­—èŠ‚æ¥éªŒè¯æ–‡ä»¶ç±»å‹
      const buffer = fs.readFileSync(file.path)
      const detectedType = await fileType.fromBuffer(buffer)

      if (!detectedType) {
        throw new BadRequestException('æ— æ³•è¯†åˆ«çš„æ–‡ä»¶ç±»å‹')
      }

      const allowedMimeTypes = this.getAllowedMimeTypes()

      if (!allowedMimeTypes.includes(detectedType.mime)) {
        throw new BadRequestException(
          `æ–‡ä»¶å†…å®¹ä¸æ‰©å±•åä¸åŒ¹é…ï¼Œæ£€æµ‹åˆ°çš„ç±»å‹: ${detectedType.mime}`
        )
      }
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error
      }
      throw new BadRequestException('æ–‡ä»¶éªŒè¯å¤±è´¥')
    }
  }

  private getMaxFileSize(): number {
    switch (this.fileCategory) {
      case 'avatar':
        return 5 * 1024 * 1024 // 5MB
      case 'cover':
        return 10 * 1024 * 1024 // 10MB
      case 'audio':
        return 50 * 1024 * 1024 // 50MB
      case 'image':
        return 20 * 1024 * 1024 // 20MB
      default:
        return 50 * 1024 * 1024 // 50MB
    }
  }

  private getAllowedExtensions(): string[] {
    switch (this.fileCategory) {
      case 'audio':
        return ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac']
      case 'image':
      case 'avatar':
      case 'cover':
        return ['jpg', 'jpeg', 'png', 'webp']
      case 'mixed':
        return ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac', 'jpg', 'jpeg', 'png', 'webp']
      default:
        return []
    }
  }

  private getAllowedMimeTypes(): string[] {
    switch (this.fileCategory) {
      case 'audio':
        return [
          'audio/mpeg',
          'audio/wav',
          'audio/flac',
          'audio/ogg',
          'audio/mp4',
          'audio/aac',
        ]
      case 'image':
      case 'avatar':
      case 'cover':
        return [
          'image/jpeg',
          'image/png',
          'image/webp',
        ]
      case 'mixed':
        return [
          'audio/mpeg',
          'audio/wav',
          'audio/flac',
          'audio/ogg',
          'audio/mp4',
          'audio/aac',
          'image/jpeg',
          'image/png',
          'image/webp',
        ]
      default:
        return []
    }
  }
}
```

---

## ğŸ“± å‰ç«¯ä¸Šä¼ ç»„ä»¶

### Vue 3ä¸Šä¼ ç»„ä»¶

```vue
<!-- src/components/FileUpload.vue -->
<template>
  <div class="file-upload">
    <!-- æ‹–æ‹½ä¸Šä¼ åŒºåŸŸ -->
    <div
      class="upload-area"
      :class="{
        'drag-over': isDragOver,
        'uploading': isUploading,
        'error': hasError
      }"
      @drop="handleDrop"
      @dragover="handleDragOver"
      @dragleave="handleDragLeave"
      @click="triggerFileInput"
    >
      <input
        ref="fileInput"
        type="file"
        :multiple="multiple"
        :accept="acceptTypes"
        @change="handleFileSelect"
        style="display: none"
      />

      <div class="upload-content">
        <div v-if="!isUploading" class="upload-icon">
          <UploadIcon size="48" />
        </div>
        <div v-else class="upload-progress">
          <div class="progress-circle">
            <svg viewBox="0 0 36 36" class="circular-chart">
              <path
                class="circle-bg"
                d="M18 2.0845
                  a 15.9155 15.9155 0 0 1 0 31.831
                  a 15.9155 15.9155 0 0 1 0 -31.831"
              />
              <path
                class="circle"
                :stroke-dasharray="`${uploadProgress}, 100`"
                d="M18 2.0845
                  a 15.9155 15.9155 0 0 1 0 31.831
                  a 15.9155 15.9155 0 0 1 0 -31.831"
              />
            </svg>
            <div class="progress-text">{{ Math.round(uploadProgress) }}%</div>
          </div>
        </div>

        <div class="upload-text">
          <h3 v-if="!isUploading">
            {{ isDragOver ? 'é‡Šæ”¾æ–‡ä»¶å¼€å§‹ä¸Šä¼ ' : 'ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„' }}
          </h3>
          <h3 v-else>æ­£åœ¨ä¸Šä¼ ...</h3>
          <p>æ”¯æŒæ ¼å¼: {{ acceptTypesText }}</p>
          <p>æœ€å¤§å¤§å°: {{ maxSizeText }}</p>
        </div>
      </div>
    </div>

    <!-- æ–‡ä»¶åˆ—è¡¨ -->
    <div v-if="files.length > 0" class="file-list">
      <h4>å·²é€‰æ‹©çš„æ–‡ä»¶</h4>
      <div
        v-for="(file, index) in files"
        :key="index"
        class="file-item"
        :class="{ 'upload-success': file.uploaded, 'upload-error': file.error }"
      >
        <div class="file-info">
          <div class="file-icon">
            <FileIcon v-if="isAudioFile(file)" />
            <ImageIcon v-else />
          </div>
          <div class="file-details">
            <div class="file-name">{{ file.name }}</div>
            <div class="file-size">{{ formatFileSize(file.size) }}</div>
            <div v-if="file.error" class="file-error">{{ file.error }}</div>
          </div>
        </div>
        <div class="file-actions">
          <button
            v-if="!file.uploaded && !file.uploading"
            @click="removeFile(index)"
            class="remove-btn"
          >
            <XIcon size="16" />
          </button>
          <div v-if="file.uploading" class="file-progress">
            <div class="progress-bar">
              <div
                class="progress-fill"
                :style="{ width: `${file.progress || 0}%` }"
              ></div>
            </div>
          </div>
          <div v-if="file.uploaded" class="success-icon">
            <CheckIcon size="16" />
          </div>
        </div>
      </div>
    </div>

    <!-- ä¸Šä¼ æŒ‰é’® -->
    <div v-if="files.length > 0 && !isUploading" class="upload-actions">
      <button @click="startUpload" class="upload-btn" :disabled="isUploading">
        å¼€å§‹ä¸Šä¼ 
      </button>
      <button @click="clearFiles" class="clear-btn">
        æ¸…ç©ºåˆ—è¡¨
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineEmits, defineProps } from 'vue'
import { UploadIcon, FileIcon, ImageIcon, XIcon, CheckIcon } from 'lucide-vue-next'
import { uploadApi } from '@/services/upload-api'

interface FileItem {
  file: File
  name: string
  size: number
  type: string
  uploading?: boolean
  uploaded?: boolean
  progress?: number
  error?: string
  result?: any
}

const props = defineProps<{
  uploadType: 'audio' | 'image' | 'mixed'
  multiple?: boolean
  maxSize?: number // MB
}>()

const emit = defineEmits<{
  success: [files: any[]]
  error: [error: string]
  progress: [progress: number]
}>()

// å“åº”å¼æ•°æ®
const fileInput = ref<HTMLInputElement>()
const files = ref<FileItem[]>([])
const isDragOver = ref(false)
const isUploading = ref(false)
const uploadProgress = ref(0)
const hasError = ref(false)

// è®¡ç®—å±æ€§
const acceptTypes = computed(() => {
  switch (props.uploadType) {
    case 'audio':
      return '.mp3,.wav,.flac,.ogg,.m4a,.aac'
    case 'image':
      return '.jpg,.jpeg,.png,.webp'
    case 'mixed':
      return '.mp3,.wav,.flac,.ogg,.m4a,.aac,.jpg,.jpeg,.png,.webp'
    default:
      return '*'
  }
})

const acceptTypesText = computed(() => {
  switch (props.uploadType) {
    case 'audio':
      return 'MP3, WAV, FLAC, OGG, M4A, AAC'
    case 'image':
      return 'JPG, PNG, WebP'
    case 'mixed':
      return 'éŸ³é¢‘å’Œå›¾ç‰‡æ–‡ä»¶'
    default:
      return 'æ‰€æœ‰æ–‡ä»¶'
  }
})

const maxSizeText = computed(() => {
  const maxSize = props.maxSize || 50
  return `${maxSize}MB`
})

// æ–¹æ³•
const triggerFileInput = () => {
  if (!isUploading.value) {
    fileInput.value?.click()
  }
}

const handleFileSelect = (event: Event) => {
  const target = event.target as HTMLInputElement
  if (target.files) {
    addFiles(Array.from(target.files))
  }
}

const handleDrop = (event: DragEvent) => {
  event.preventDefault()
  isDragOver.value = false

  if (event.dataTransfer?.files) {
    addFiles(Array.from(event.dataTransfer.files))
  }
}

const handleDragOver = (event: DragEvent) => {
  event.preventDefault()
  isDragOver.value = true
}

const handleDragLeave = () => {
  isDragOver.value = false
}

const addFiles = (newFiles: File[]) => {
  const validFiles = newFiles.filter(file => validateFile(file))

  const fileItems: FileItem[] = validFiles.map(file => ({
    file,
    name: file.name,
    size: file.size,
    type: file.type,
  }))

  if (props.multiple) {
    files.value.push(...fileItems)
  } else {
    files.value = fileItems.slice(0, 1)
  }
}

const validateFile = (file: File): boolean => {
  const maxSize = (props.maxSize || 50) * 1024 * 1024

  if (file.size > maxSize) {
    hasError.value = true
    emit('error', `æ–‡ä»¶ ${file.name} å¤§å°è¶…è¿‡é™åˆ¶`)
    return false
  }

  return true
}

const removeFile = (index: number) => {
  files.value.splice(index, 1)
}

const clearFiles = () => {
  files.value = []
  hasError.value = false
}

const startUpload = async () => {
  if (files.value.length === 0) return

  isUploading.value = true
  uploadProgress.value = 0

  const results = []
  const totalFiles = files.value.length

  for (let i = 0; i < files.value.length; i++) {
    const fileItem = files.value[i]
    fileItem.uploading = true

    try {
      const result = await uploadFile(fileItem)
      fileItem.uploaded = true
      fileItem.result = result
      results.push(result)
    } catch (error) {
      fileItem.error = error.message
      hasError.value = true
    } finally {
      fileItem.uploading = false
      uploadProgress.value = ((i + 1) / totalFiles) * 100
      emit('progress', uploadProgress.value)
    }
  }

  isUploading.value = false

  if (results.length > 0) {
    emit('success', results)
  }
}

const uploadFile = async (fileItem: FileItem) => {
  const formData = new FormData()
  formData.append('file', fileItem.file)

  const onProgress = (progress: number) => {
    fileItem.progress = progress
  }

  switch (props.uploadType) {
    case 'audio':
      return uploadApi.uploadAudio(formData, onProgress)
    case 'image':
      return uploadApi.uploadImage(formData, onProgress)
    default:
      return uploadApi.uploadFile(formData, onProgress)
  }
}

const isAudioFile = (fileItem: FileItem): boolean => {
  return fileItem.type.startsWith('audio/')
}

const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}
</script>

<style scoped>
.file-upload {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.upload-area {
  border: 2px dashed #d1d5db;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #f9fafb;
}

.upload-area:hover {
  border-color: #3b82f6;
  background-color: #eff6ff;
}

.upload-area.drag-over {
  border-color: #3b82f6;
  background-color: #dbeafe;
}

.upload-area.uploading {
  cursor: not-allowed;
  opacity: 0.7;
}

.upload-area.error {
  border-color: #ef4444;
  background-color: #fef2f2;
}

.upload-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.upload-icon {
  color: #6b7280;
}

.progress-circle {
  position: relative;
  width: 60px;
  height: 60px;
}

.circular-chart {
  width: 100%;
  height: 100%;
}

.circle-bg {
  fill: none;
  stroke: #e5e7eb;
  stroke-width: 2;
}

.circle {
  fill: none;
  stroke: #3b82f6;
  stroke-width: 2;
  stroke-linecap: round;
  transition: stroke-dasharray 0.3s ease;
}

.progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.875rem;
  font-weight: 600;
  color: #3b82f6;
}

.file-list {
  margin-top: 1.5rem;
}

.file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  margin-bottom: 0.5rem;
  background-color: white;
}

.file-item.upload-success {
  border-color: #10b981;
  background-color: #f0fdf4;
}

.file-item.upload-error {
  border-color: #ef4444;
  background-color: #fef2f2;
}

.file-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.file-icon {
  color: #6b7280;
}

.file-details {
  flex: 1;
}

.file-name {
  font-weight: 500;
  color: #111827;
}

.file-size {
  font-size: 0.875rem;
  color: #6b7280;
}

.file-error {
  font-size: 0.875rem;
  color: #ef4444;
}

.file-actions {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.remove-btn {
  padding: 0.25rem;
  border: none;
  background: none;
  color: #6b7280;
  cursor: pointer;
  border-radius: 4px;
}

.remove-btn:hover {
  color: #ef4444;
  background-color: #fef2f2;
}

.progress-bar {
  width: 100px;
  height: 4px;
  background-color: #e5e7eb;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background-color: #3b82f6;
  transition: width 0.3s ease;
}

.success-icon {
  color: #10b981;
}

.upload-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

.upload-btn {
  flex: 1;
  padding: 0.75rem 1.5rem;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.upload-btn:hover:not(:disabled) {
  background-color: #2563eb;
}

.upload-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.clear-btn {
  padding: 0.75rem 1.5rem;
  background-color: #f3f4f6;
  color: #374151;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.clear-btn:hover {
  background-color: #e5e7eb;
}
</style>
```

---

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†æ–‡ä»¶ä¸Šä¼ ç³»ç»Ÿçš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬æœåŠ¡ç«¯å¤„ç†ã€æ–‡ä»¶éªŒè¯ã€å­˜å‚¨ç®¡ç†å’Œå‰ç«¯ç»„ä»¶ã€‚*
```
```

---

## ğŸ› ï¸ æ–‡ä»¶å¤„ç†æœåŠ¡

### æ ¸å¿ƒä¸Šä¼ æœåŠ¡

```typescript
// src/upload/upload.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { Song } from '../entities/song.entity'
import { FileProcessorService } from './file-processor.service'
import { StorageService } from './storage.service'
import { UploadAudioDto, UploadImageDto } from './dto/upload.dto'
import * as path from 'path'
import * as fs from 'fs/promises'

@Injectable()
export class UploadService {
  private readonly logger = new Logger(UploadService.name)

  constructor(
    @InjectRepository(Song)
    private readonly songRepository: Repository<Song>,
    private readonly configService: ConfigService,
    private readonly fileProcessor: FileProcessorService,
    private readonly storageService: StorageService,
  ) {}

  /**
   * å¤„ç†éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ 
   */
  async processAudioFile(
    file: Express.Multer.File,
    uploadDto: UploadAudioDto,
    userId: string,
  ) {
    this.logger.log(`Processing audio file: ${file.originalname}`)

    try {
      // 1. éªŒè¯æ–‡ä»¶æ ¼å¼å’Œå¤§å°
      await this.validateAudioFile(file)

      // 2. æå–éŸ³é¢‘å…ƒæ•°æ®
      const metadata = await this.fileProcessor.extractAudioMetadata(file.path)

      // 3. è½¬æ¢éŸ³é¢‘æ ¼å¼ï¼ˆå¦‚æœéœ€è¦ï¼‰
      const processedFile = await this.fileProcessor.convertAudio(
        file.path,
        this.configService.get('upload.audio.outputFormat'),
      )

      // 4. ç”Ÿæˆç¼©ç•¥å›¾ï¼ˆä»éŸ³é¢‘æ–‡ä»¶ä¸­æå–æˆ–ä½¿ç”¨é»˜è®¤ï¼‰
      const coverPath = await this.fileProcessor.extractOrGenerateCover(
        processedFile.path,
        metadata,
      )

      // 5. ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡
      const [audioUrl, coverUrl] = await Promise.all([
        this.storageService.uploadFile(processedFile.path, 'audio'),
        this.storageService.uploadFile(coverPath, 'images'),
      ])

      // 6. ä¿å­˜åˆ°æ•°æ®åº“
      const song = this.songRepository.create({
        title: uploadDto.title || metadata.title || path.parse(file.originalname).name,
        artist: uploadDto.artist || metadata.artist || 'Unknown Artist',
        album: uploadDto.album || metadata.album || 'Unknown Album',
        genre: uploadDto.genre || metadata.genre,
        year: uploadDto.year || metadata.year,
        duration: Math.round(metadata.duration),
        audioUrl,
        coverUrl,
        fileSize: processedFile.size,
        originalFileName: file.originalname,
        lyrics: uploadDto.lyrics,
      })

      const savedSong = await this.songRepository.save(song)

      // 7. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempFiles([file.path, processedFile.path, coverPath])

      this.logger.log(`Audio file processed successfully: ${savedSong.id}`)

      return {
        id: savedSong.id,
        title: savedSong.title,
        artist: savedSong.artist,
        duration: savedSong.duration,
        audioUrl: savedSong.audioUrl,
        coverUrl: savedSong.coverUrl,
        fileSize: savedSong.fileSize,
      }
    } catch (error) {
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempFiles([file.path])
      throw error
    }
  }

  /**
   * å¤„ç†å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ 
   */
  async processImageFile(
    file: Express.Multer.File,
    uploadDto: UploadImageDto,
    userId: string,
  ) {
    this.logger.log(`Processing image file: ${file.originalname}`)

    try {
      // 1. éªŒè¯å›¾ç‰‡æ–‡ä»¶
      await this.validateImageFile(file)

      // 2. å¤„ç†å›¾ç‰‡ï¼ˆå‹ç¼©ã€è°ƒæ•´å¤§å°ï¼‰
      const processedImages = await this.fileProcessor.processImage(
        file.path,
        uploadDto.type || 'general',
      )

      // 3. ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡
      const uploadPromises = processedImages.map(img =>
        this.storageService.uploadFile(img.path, 'images')
      )
      const urls = await Promise.all(uploadPromises)

      // 4. æ„å»ºè¿”å›ç»“æœ
      const result = {
        original: urls[0],
        thumbnails: {},
      }

      processedImages.forEach((img, index) => {
        if (img.size) {
          result.thumbnails[`${img.size}x${img.size}`] = urls[index]
        }
      })

      // 5. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      const tempFiles = [file.path, ...processedImages.map(img => img.path)]
      await this.cleanupTempFiles(tempFiles)

      this.logger.log(`Image file processed successfully`)

      return result
    } catch (error) {
      await this.cleanupTempFiles([file.path])
      throw error
    }
  }

  /**
   * å¤„ç†å¤´åƒä¸Šä¼ 
   */
  async processAvatarFile(file: Express.Multer.File, userId: string) {
    const uploadDto: UploadImageDto = { type: 'avatar' }
    return this.processImageFile(file, uploadDto, userId)
  }

  /**
   * å¤„ç†å°é¢å›¾ç‰‡ä¸Šä¼ 
   */
  async processCoverFile(
    file: Express.Multer.File,
    type: 'song' | 'playlist' | 'album',
    userId: string,
  ) {
    const uploadDto: UploadImageDto = { type: 'cover' }
    return this.processImageFile(file, uploadDto, userId)
  }

  /**
   * æ‰¹é‡å¤„ç†æ–‡ä»¶
   */
  async processMultipleFiles(files: Express.Multer.File[], userId: string) {
    const results = []

    for (const file of files) {
      try {
        if (this.isAudioFile(file)) {
          const result = await this.processAudioFile(
            file,
            { title: path.parse(file.originalname).name },
            userId,
          )
          results.push({ type: 'audio', ...result })
        } else if (this.isImageFile(file)) {
          const result = await this.processImageFile(
            file,
            { type: 'general' },
            userId,
          )
          results.push({ type: 'image', ...result })
        }
      } catch (error) {
        this.logger.error(`Failed to process file ${file.originalname}:`, error)
        results.push({
          type: 'error',
          filename: file.originalname,
          error: error.message,
        })
      }
    }

    return results
  }

  /**
   * éªŒè¯éŸ³é¢‘æ–‡ä»¶
   */
  private async validateAudioFile(file: Express.Multer.File) {
    const allowedFormats = this.configService.get<string[]>('upload.audio.allowedFormats')
    const maxSize = this.configService.get<number>('upload.maxFileSize')

    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    
    if (!allowedFormats.includes(ext)) {
      throw new Error(`ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ${ext}`)
    }

    if (file.size > maxSize) {
      throw new Error(`æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶: ${Math.round(file.size / 1024 / 1024)}MB`)
    }
  }

  /**
   * éªŒè¯å›¾ç‰‡æ–‡ä»¶
   */
  private async validateImageFile(file: Express.Multer.File) {
    const allowedFormats = this.configService.get<string[]>('upload.image.allowedFormats')
    const maxSize = this.configService.get<number>('upload.maxFileSize')

    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    
    if (!allowedFormats.includes(ext)) {
      throw new Error(`ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼: ${ext}`)
    }

    if (file.size > maxSize) {
      throw new Error(`æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶: ${Math.round(file.size / 1024 / 1024)}MB`)
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶
   */
  private isAudioFile(file: Express.Multer.File): boolean {
    const audioFormats = this.configService.get<string[]>('upload.audio.allowedFormats')
    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    return audioFormats.includes(ext)
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºå›¾ç‰‡æ–‡ä»¶
   */
  private isImageFile(file: Express.Multer.File): boolean {
    const imageFormats = this.configService.get<string[]>('upload.image.allowedFormats')
    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    return imageFormats.includes(ext)
  }

  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   */
  private async cleanupTempFiles(filePaths: string[]) {
    for (const filePath of filePaths) {
      try {
        await fs.unlink(filePath)
      } catch (error) {
        this.logger.warn(`Failed to cleanup temp file: ${filePath}`)
      }
    }
  }
}
```
