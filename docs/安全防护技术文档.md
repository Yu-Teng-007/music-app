# 🛡️ 安全防护技术文档

**技术栈**: NestJS + JWT + CSRF + Rate Limiting  
**版本**: v1.0  
**更新日期**: 2025-06-27

---

## 📋 安全防护概览

安全防护系统采用多层防护架构，包括身份认证、授权控制、输入验证、CSRF防护、XSS防护、SQL注入防护、速率限制等多种安全机制，确保应用的全面安全。

### 🏗️ 安全架构设计

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   网络层安全    │    │   应用层安全    │    │   数据层安全    │
│                 │    │                 │    │                 │
│ • HTTPS/TLS     │───►│ • JWT认证       │───►│ • 数据加密      │
│ • 防火墙        │    │ • CSRF防护      │    │ • 访问控制      │
│ • DDoS防护      │    │ • XSS防护       │    │ • 审计日志      │
│ • CDN安全       │    │ • 输入验证      │    │ • 备份加密      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   监控告警      │    │   威胁检测      │    │   合规审计      │
│                 │    │                 │    │                 │
│ • 安全监控      │    │ • 异常检测      │    │ • 安全扫描      │
│ • 日志分析      │    │ • 行为分析      │    │ • 漏洞评估      │
│ • 实时告警      │    │ • 风险评估      │    │ • 合规检查      │
│ • 事件响应      │    │ • 自动阻断      │    │ • 安全报告      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 🔐 身份认证和授权

### JWT认证增强

```typescript
// src/auth/enhanced-jwt.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { ConfigService } from '@nestjs/config'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'
import * as crypto from 'crypto'

@Injectable()
export class EnhancedJwtService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    @InjectRedis() private readonly redis: Redis,
  ) {}

  /**
   * 生成安全的JWT令牌
   */
  async generateSecureToken(user: any, deviceInfo: any): Promise<{
    accessToken: string
    refreshToken: string
    fingerprint: string
  }> {
    // 生成设备指纹
    const fingerprint = this.generateDeviceFingerprint(deviceInfo)
    
    // 生成唯一的JTI
    const jti = crypto.randomUUID()
    
    const payload = {
      sub: user.id,
      username: user.username,
      phone: user.phone,
      jti,
      fingerprint: fingerprint.substring(0, 16), // 只存储部分指纹
      iat: Math.floor(Date.now() / 1000),
    }

    // 生成访问令牌
    const accessToken = this.jwtService.sign(payload, {
      expiresIn: '15m',
      issuer: this.configService.get('jwt.issuer'),
      audience: this.configService.get('jwt.audience'),
    })

    // 生成刷新令牌
    const refreshToken = this.jwtService.sign(
      { sub: user.id, jti, type: 'refresh' },
      {
        secret: this.configService.get('jwt.refreshSecret'),
        expiresIn: '7d',
      }
    )

    // 存储令牌信息到Redis
    await this.storeTokenInfo(jti, {
      userId: user.id,
      fingerprint,
      deviceInfo,
      createdAt: new Date(),
      lastUsed: new Date(),
    })

    return { accessToken, refreshToken, fingerprint }
  }

  /**
   * 验证令牌安全性
   */
  async verifySecureToken(token: string, deviceInfo: any): Promise<any> {
    try {
      const payload = this.jwtService.verify(token)
      
      // 验证设备指纹
      const currentFingerprint = this.generateDeviceFingerprint(deviceInfo)
      const storedInfo = await this.getTokenInfo(payload.jti)
      
      if (!storedInfo || storedInfo.fingerprint !== currentFingerprint) {
        throw new UnauthorizedException('Device fingerprint mismatch')
      }

      // 检查令牌是否在黑名单中
      const isBlacklisted = await this.isTokenBlacklisted(payload.jti)
      if (isBlacklisted) {
        throw new UnauthorizedException('Token has been revoked')
      }

      // 更新最后使用时间
      await this.updateTokenLastUsed(payload.jti)

      return payload
    } catch (error) {
      throw new UnauthorizedException('Invalid token')
    }
  }

  /**
   * 撤销令牌
   */
  async revokeToken(jti: string): Promise<void> {
    await this.redis.sadd('token_blacklist', jti)
    await this.redis.del(`token_info:${jti}`)
  }

  /**
   * 撤销用户所有令牌
   */
  async revokeAllUserTokens(userId: string): Promise<void> {
    const pattern = `token_info:*`
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const info = await this.redis.get(key)
      if (info) {
        const tokenInfo = JSON.parse(info)
        if (tokenInfo.userId === userId) {
          const jti = key.split(':')[1]
          await this.revokeToken(jti)
        }
      }
    }
  }

  /**
   * 生成设备指纹
   */
  private generateDeviceFingerprint(deviceInfo: any): string {
    const fingerprint = [
      deviceInfo.userAgent || '',
      deviceInfo.ip || '',
      deviceInfo.acceptLanguage || '',
      deviceInfo.timezone || '',
    ].join('|')

    return crypto.createHash('sha256').update(fingerprint).digest('hex')
  }

  /**
   * 存储令牌信息
   */
  private async storeTokenInfo(jti: string, info: any): Promise<void> {
    await this.redis.setex(
      `token_info:${jti}`,
      7 * 24 * 60 * 60, // 7天
      JSON.stringify(info)
    )
  }

  /**
   * 获取令牌信息
   */
  private async getTokenInfo(jti: string): Promise<any> {
    const info = await this.redis.get(`token_info:${jti}`)
    return info ? JSON.parse(info) : null
  }

  /**
   * 检查令牌是否在黑名单中
   */
  private async isTokenBlacklisted(jti: string): Promise<boolean> {
    return await this.redis.sismember('token_blacklist', jti)
  }

  /**
   * 更新令牌最后使用时间
   */
  private async updateTokenLastUsed(jti: string): Promise<void> {
    const info = await this.getTokenInfo(jti)
    if (info) {
      info.lastUsed = new Date()
      await this.storeTokenInfo(jti, info)
    }
  }
}
```

### 权限控制系统

```typescript
// src/auth/rbac/rbac.service.ts
import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { User } from '../../entities/user.entity'
import { Role } from '../../entities/role.entity'
import { Permission } from '../../entities/permission.entity'

export enum Action {
  CREATE = 'create',
  READ = 'read',
  UPDATE = 'update',
  DELETE = 'delete',
  MANAGE = 'manage',
}

export enum Resource {
  USER = 'user',
  SONG = 'song',
  PLAYLIST = 'playlist',
  COMMENT = 'comment',
  ADMIN = 'admin',
}

@Injectable()
export class RBACService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Role)
    private readonly roleRepository: Repository<Role>,
    @InjectRepository(Permission)
    private readonly permissionRepository: Repository<Permission>,
  ) {}

  /**
   * 检查用户权限
   */
  async checkPermission(
    userId: string,
    action: Action,
    resource: Resource,
    resourceId?: string
  ): Promise<boolean> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles', 'roles.permissions'],
    })

    if (!user) {
      return false
    }

    // 检查用户角色权限
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        if (this.matchPermission(permission, action, resource)) {
          // 检查资源级权限
          if (resourceId && !this.checkResourceAccess(user, resource, resourceId)) {
            continue
          }
          return true
        }
      }
    }

    // 检查资源所有权
    if (resourceId) {
      return this.checkOwnership(userId, resource, resourceId)
    }

    return false
  }

  /**
   * 获取用户权限列表
   */
  async getUserPermissions(userId: string): Promise<string[]> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles', 'roles.permissions'],
    })

    if (!user) {
      return []
    }

    const permissions = new Set<string>()
    
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        permissions.add(`${permission.action}:${permission.resource}`)
      }
    }

    return Array.from(permissions)
  }

  /**
   * 分配角色给用户
   */
  async assignRole(userId: string, roleId: string): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles'],
    })

    const role = await this.roleRepository.findOne({
      where: { id: roleId },
    })

    if (user && role) {
      user.roles.push(role)
      await this.userRepository.save(user)
    }
  }

  /**
   * 移除用户角色
   */
  async removeRole(userId: string, roleId: string): Promise<void> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles'],
    })

    if (user) {
      user.roles = user.roles.filter(role => role.id !== roleId)
      await this.userRepository.save(user)
    }
  }

  /**
   * 创建角色
   */
  async createRole(name: string, description: string, permissions: string[]): Promise<Role> {
    const role = this.roleRepository.create({
      name,
      description,
    })

    const savedRole = await this.roleRepository.save(role)

    // 分配权限
    for (const permissionId of permissions) {
      const permission = await this.permissionRepository.findOne({
        where: { id: permissionId },
      })
      if (permission) {
        savedRole.permissions.push(permission)
      }
    }

    return this.roleRepository.save(savedRole)
  }

  /**
   * 匹配权限
   */
  private matchPermission(
    permission: Permission,
    action: Action,
    resource: Resource
  ): boolean {
    // 检查通配符权限
    if (permission.action === Action.MANAGE || permission.action === action) {
      if (permission.resource === '*' || permission.resource === resource) {
        return true
      }
    }

    return false
  }

  /**
   * 检查资源访问权限
   */
  private async checkResourceAccess(
    user: User,
    resource: Resource,
    resourceId: string
  ): Promise<boolean> {
    // 根据资源类型检查特定的访问规则
    switch (resource) {
      case Resource.PLAYLIST:
        return this.checkPlaylistAccess(user.id, resourceId)
      case Resource.USER:
        return user.id === resourceId // 用户只能访问自己的资源
      default:
        return true
    }
  }

  /**
   * 检查所有权
   */
  private async checkOwnership(
    userId: string,
    resource: Resource,
    resourceId: string
  ): Promise<boolean> {
    // 实现资源所有权检查逻辑
    // 这里应该根据具体的业务逻辑来实现
    return false
  }

  /**
   * 检查歌单访问权限
   */
  private async checkPlaylistAccess(userId: string, playlistId: string): Promise<boolean> {
    // 实现歌单访问权限检查
    // 例如：公开歌单所有人可访问，私有歌单只有所有者可访问
    return true
  }
}
```

---

## 🛡️ 输入验证和过滤

### 全局验证管道

```typescript
// src/common/pipes/validation.pipe.ts
import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  BadRequestException,
} from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToClass } from 'class-transformer'
import * as DOMPurify from 'isomorphic-dompurify'

@Injectable()
export class GlobalValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return this.sanitizeInput(value)
    }

    // 转换为类实例
    const object = plainToClass(metatype, value)
    
    // 验证
    const errors = await validate(object, {
      whitelist: true, // 只保留装饰器标记的属性
      forbidNonWhitelisted: true, // 禁止非白名单属性
      transform: true, // 自动转换类型
    })

    if (errors.length > 0) {
      const errorMessages = this.formatErrors(errors)
      throw new BadRequestException({
        message: '输入验证失败',
        errors: errorMessages,
      })
    }

    return this.sanitizeInput(object)
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }

  private formatErrors(errors: any[]): string[] {
    return errors.map(error => {
      const constraints = error.constraints
      return Object.values(constraints).join(', ')
    })
  }

  /**
   * 输入清理
   */
  private sanitizeInput(input: any): any {
    if (typeof input === 'string') {
      // XSS防护：清理HTML标签
      return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] })
    }

    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeInput(item))
    }

    if (input && typeof input === 'object') {
      const sanitized = {}
      for (const [key, value] of Object.entries(input)) {
        sanitized[this.sanitizeInput(key)] = this.sanitizeInput(value)
      }
      return sanitized
    }

    return input
  }
}
```

### SQL注入防护

```typescript
// src/common/guards/sql-injection.guard.ts
import { Injectable, CanActivate, ExecutionContext, BadRequestException } from '@nestjs/common'

@Injectable()
export class SqlInjectionGuard implements CanActivate {
  private readonly sqlInjectionPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/gi,
    /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
    /(--|\/\*|\*\/|;)/g,
    /(\b(CHAR|NCHAR|VARCHAR|NVARCHAR)\s*\(\s*\d+\s*\))/gi,
    /(\b(CAST|CONVERT|SUBSTRING|ASCII|CHAR_LENGTH)\s*\()/gi,
  ]

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest()
    
    // 检查查询参数
    this.validateInput(request.query, 'query parameters')
    
    // 检查请求体
    this.validateInput(request.body, 'request body')
    
    // 检查路径参数
    this.validateInput(request.params, 'path parameters')

    return true
  }

  private validateInput(input: any, source: string): void {
    if (!input) return

    const inputString = JSON.stringify(input)
    
    for (const pattern of this.sqlInjectionPatterns) {
      if (pattern.test(inputString)) {
        throw new BadRequestException(
          `Potential SQL injection detected in ${source}`
        )
      }
    }
  }
}
```

---

## 🚫 CSRF防护增强

### 动态CSRF令牌

```typescript
// src/security/csrf/dynamic-csrf.service.ts
import { Injectable } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'
import * as crypto from 'crypto'

@Injectable()
export class DynamicCSRFService {
  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * 生成CSRF令牌
   */
  async generateToken(sessionId: string, action?: string): Promise<string> {
    const timestamp = Date.now()
    const random = crypto.randomBytes(16).toString('hex')
    const actionSuffix = action ? `:${action}` : ''
    
    // 创建令牌数据
    const tokenData = {
      sessionId,
      timestamp,
      random,
      action,
    }

    // 生成令牌
    const token = this.createToken(tokenData)
    
    // 存储令牌信息
    await this.redis.setex(
      `csrf:${token}`,
      3600, // 1小时过期
      JSON.stringify(tokenData)
    )

    return token
  }

  /**
   * 验证CSRF令牌
   */
  async validateToken(
    token: string,
    sessionId: string,
    action?: string
  ): Promise<boolean> {
    try {
      // 从Redis获取令牌数据
      const storedData = await this.redis.get(`csrf:${token}`)
      if (!storedData) {
        return false
      }

      const tokenData = JSON.parse(storedData)

      // 验证会话ID
      if (tokenData.sessionId !== sessionId) {
        return false
      }

      // 验证动作（如果指定）
      if (action && tokenData.action && tokenData.action !== action) {
        return false
      }

      // 验证时间戳（防止重放攻击）
      const now = Date.now()
      const tokenAge = now - tokenData.timestamp
      if (tokenAge > 3600000) { // 1小时
        return false
      }

      // 验证令牌完整性
      const expectedToken = this.createToken(tokenData)
      if (token !== expectedToken) {
        return false
      }

      // 一次性使用：验证后删除令牌
      await this.redis.del(`csrf:${token}`)

      return true
    } catch (error) {
      return false
    }
  }

  /**
   * 创建令牌
   */
  private createToken(tokenData: any): string {
    const payload = `${tokenData.sessionId}:${tokenData.timestamp}:${tokenData.random}`
    const signature = crypto
      .createHmac('sha256', process.env.CSRF_SECRET || 'default-secret')
      .update(payload)
      .digest('hex')

    return Buffer.from(`${payload}:${signature}`).toString('base64')
  }

  /**
   * 清理过期令牌
   */
  async cleanupExpiredTokens(): Promise<void> {
    const pattern = 'csrf:*'
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const ttl = await this.redis.ttl(key)
      if (ttl <= 0) {
        await this.redis.del(key)
      }
    }
  }
}
```

### CSRF守卫

```typescript
// src/security/csrf/csrf.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { DynamicCSRFService } from './dynamic-csrf.service'

@Injectable()
export class CSRFGuard implements CanActivate {
  constructor(
    private readonly csrfService: DynamicCSRFService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 检查是否跳过CSRF验证
    const skipCSRF = this.reflector.get<boolean>('skipCSRF', context.getHandler())
    if (skipCSRF) {
      return true
    }

    const request = context.switchToHttp().getRequest()
    const method = request.method.toLowerCase()

    // 只对状态改变的请求进行CSRF验证
    if (!['post', 'put', 'patch', 'delete'].includes(method)) {
      return true
    }

    // 获取CSRF令牌
    const token = this.extractCSRFToken(request)
    if (!token) {
      throw new ForbiddenException('CSRF token missing')
    }

    // 获取会话ID
    const sessionId = this.extractSessionId(request)
    if (!sessionId) {
      throw new ForbiddenException('Session ID missing')
    }

    // 获取动作（可选）
    const action = this.extractAction(request)

    // 验证CSRF令牌
    const isValid = await this.csrfService.validateToken(token, sessionId, action)
    if (!isValid) {
      throw new ForbiddenException('Invalid CSRF token')
    }

    return true
  }

  private extractCSRFToken(request: any): string | null {
    // 从多个位置尝试获取CSRF令牌
    return (
      request.headers['x-csrf-token'] ||
      request.headers['x-xsrf-token'] ||
      request.body?._csrf ||
      request.query?._csrf ||
      null
    )
  }

  private extractSessionId(request: any): string | null {
    // 从JWT令牌或会话中获取会话ID
    return request.user?.jti || request.sessionID || null
  }

  private extractAction(request: any): string | null {
    // 从请求中提取动作信息
    const path = request.route?.path || request.url
    const method = request.method.toLowerCase()
    return `${method}:${path}`
  }
}
```

---

## 🚦 速率限制和防护

### 智能速率限制

```typescript
// src/security/rate-limit/smart-rate-limit.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'

interface RateLimitConfig {
  windowMs: number // 时间窗口（毫秒）
  maxRequests: number // 最大请求数
  skipSuccessfulRequests?: boolean // 是否跳过成功请求
  skipFailedRequests?: boolean // 是否跳过失败请求
  keyGenerator?: (req: any) => string // 自定义键生成器
}

interface RateLimitResult {
  allowed: boolean
  remaining: number
  resetTime: number
  retryAfter?: number
}

@Injectable()
export class SmartRateLimitService {
  private readonly logger = new Logger(SmartRateLimitService.name)

  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * 检查速率限制
   */
  async checkRateLimit(
    key: string,
    config: RateLimitConfig
  ): Promise<RateLimitResult> {
    const now = Date.now()
    const windowStart = now - config.windowMs
    
    // 使用滑动窗口算法
    const pipeline = this.redis.pipeline()
    
    // 移除过期的请求记录
    pipeline.zremrangebyscore(key, 0, windowStart)
    
    // 添加当前请求
    pipeline.zadd(key, now, `${now}-${Math.random()}`)
    
    // 获取当前窗口内的请求数
    pipeline.zcard(key)
    
    // 设置过期时间
    pipeline.expire(key, Math.ceil(config.windowMs / 1000))
    
    const results = await pipeline.exec()
    const requestCount = results[2][1] as number

    const remaining = Math.max(0, config.maxRequests - requestCount)
    const resetTime = now + config.windowMs

    if (requestCount > config.maxRequests) {
      const retryAfter = Math.ceil(config.windowMs / 1000)
      
      this.logger.warn(`Rate limit exceeded for key: ${key}`, {
        requestCount,
        maxRequests: config.maxRequests,
        windowMs: config.windowMs,
      })

      return {
        allowed: false,
        remaining: 0,
        resetTime,
        retryAfter,
      }
    }

    return {
      allowed: true,
      remaining,
      resetTime,
    }
  }

  /**
   * 自适应速率限制
   */
  async adaptiveRateLimit(
    key: string,
    baseConfig: RateLimitConfig,
    errorRate: number
  ): Promise<RateLimitResult> {
    // 根据错误率调整限制
    let adjustedConfig = { ...baseConfig }
    
    if (errorRate > 0.1) { // 错误率超过10%
      adjustedConfig.maxRequests = Math.floor(baseConfig.maxRequests * 0.5)
    } else if (errorRate > 0.05) { // 错误率超过5%
      adjustedConfig.maxRequests = Math.floor(baseConfig.maxRequests * 0.7)
    }

    return this.checkRateLimit(key, adjustedConfig)
  }

  /**
   * 分布式速率限制
   */
  async distributedRateLimit(
    key: string,
    config: RateLimitConfig,
    nodeId: string
  ): Promise<RateLimitResult> {
    // 为每个节点创建独立的计数器
    const nodeKey = `${key}:${nodeId}`
    
    // 获取所有节点的请求数
    const pattern = `${key}:*`
    const keys = await this.redis.keys(pattern)
    
    let totalRequests = 0
    for (const nodeKey of keys) {
      const count = await this.redis.zcard(nodeKey)
      totalRequests += count
    }

    // 计算当前节点的配额
    const nodeQuota = Math.ceil(config.maxRequests / keys.length)
    const nodeConfig = { ...config, maxRequests: nodeQuota }

    return this.checkRateLimit(nodeKey, nodeConfig)
  }

  /**
   * 获取速率限制统计
   */
  async getRateLimitStats(keyPattern: string): Promise<any> {
    const keys = await this.redis.keys(keyPattern)
    const stats = []

    for (const key of keys) {
      const count = await this.redis.zcard(key)
      const ttl = await this.redis.ttl(key)
      
      stats.push({
        key,
        requestCount: count,
        ttl,
      })
    }

    return stats
  }

  /**
   * 清理过期的速率限制数据
   */
  async cleanupExpiredData(): Promise<void> {
    const pattern = 'rate_limit:*'
    const keys = await this.redis.keys(pattern)
    
    for (const key of keys) {
      const ttl = await this.redis.ttl(key)
      if (ttl <= 0) {
        await this.redis.del(key)
      }
    }
  }
}
```

### 速率限制守卫

```typescript
// src/security/rate-limit/rate-limit.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { SmartRateLimitService } from './smart-rate-limit.service'

interface RateLimitOptions {
  windowMs?: number
  maxRequests?: number
  keyGenerator?: (req: any) => string
  skipIf?: (req: any) => boolean
  message?: string
}

@Injectable()
export class RateLimitGuard implements CanActivate {
  constructor(
    private readonly rateLimitService: SmartRateLimitService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()
    const response = context.switchToHttp().getResponse()

    // 获取速率限制配置
    const options = this.reflector.get<RateLimitOptions>(
      'rateLimit',
      context.getHandler(),
    ) || this.getDefaultOptions()

    // 检查是否跳过
    if (options.skipIf && options.skipIf(request)) {
      return true
    }

    // 生成限制键
    const key = this.generateKey(request, options.keyGenerator)

    // 检查速率限制
    const result = await this.rateLimitService.checkRateLimit(key, {
      windowMs: options.windowMs || 60000, // 默认1分钟
      maxRequests: options.maxRequests || 100, // 默认100次
    })

    // 设置响应头
    response.setHeader('X-RateLimit-Limit', options.maxRequests)
    response.setHeader('X-RateLimit-Remaining', result.remaining)
    response.setHeader('X-RateLimit-Reset', new Date(result.resetTime).toISOString())

    if (!result.allowed) {
      response.setHeader('Retry-After', result.retryAfter)

      throw new HttpException(
        {
          statusCode: HttpStatus.TOO_MANY_REQUESTS,
          message: options.message || 'Too many requests',
          retryAfter: result.retryAfter,
        },
        HttpStatus.TOO_MANY_REQUESTS,
      )
    }

    return true
  }

  private generateKey(request: any, keyGenerator?: (req: any) => string): string {
    if (keyGenerator) {
      return `rate_limit:${keyGenerator(request)}`
    }

    // 默认键生成策略
    const ip = request.ip || request.connection.remoteAddress
    const userId = request.user?.id || 'anonymous'
    const endpoint = `${request.method}:${request.route?.path || request.url}`

    return `rate_limit:${ip}:${userId}:${endpoint}`
  }

  private getDefaultOptions(): RateLimitOptions {
    return {
      windowMs: 60000, // 1分钟
      maxRequests: 100, // 100次请求
      message: 'Too many requests, please try again later',
    }
  }
}
```

---

## 🔍 安全监控和审计

### 安全事件监控

```typescript
// src/security/monitoring/security-monitor.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { InjectRedis } from '@nestjs-modules/ioredis'
import Redis from 'ioredis'

export enum SecurityEventType {
  LOGIN_ATTEMPT = 'login_attempt',
  LOGIN_SUCCESS = 'login_success',
  LOGIN_FAILURE = 'login_failure',
  PERMISSION_DENIED = 'permission_denied',
  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',
  SUSPICIOUS_ACTIVITY = 'suspicious_activity',
  DATA_ACCESS = 'data_access',
  ADMIN_ACTION = 'admin_action',
}

export interface SecurityEvent {
  type: SecurityEventType
  userId?: string
  ip: string
  userAgent: string
  timestamp: Date
  details: any
  severity: 'low' | 'medium' | 'high' | 'critical'
}

@Injectable()
export class SecurityMonitorService {
  private readonly logger = new Logger(SecurityMonitorService.name)

  constructor(@InjectRedis() private readonly redis: Redis) {}

  /**
   * 记录安全事件
   */
  async logSecurityEvent(event: SecurityEvent): Promise<void> {
    try {
      // 存储事件到Redis
      const eventKey = `security_event:${Date.now()}:${Math.random()}`
      await this.redis.setex(
        eventKey,
        30 * 24 * 60 * 60, // 保存30天
        JSON.stringify(event)
      )

      // 添加到事件索引
      await this.redis.zadd(
        `security_events:${event.type}`,
        event.timestamp.getTime(),
        eventKey
      )

      // 用户事件索引
      if (event.userId) {
        await this.redis.zadd(
          `user_security_events:${event.userId}`,
          event.timestamp.getTime(),
          eventKey
        )
      }

      // IP事件索引
      await this.redis.zadd(
        `ip_security_events:${event.ip}`,
        event.timestamp.getTime(),
        eventKey
      )

      // 实时告警检查
      await this.checkRealTimeAlerts(event)

      this.logger.log(`Security event logged: ${event.type}`, {
        userId: event.userId,
        ip: event.ip,
        severity: event.severity,
      })
    } catch (error) {
      this.logger.error('Failed to log security event:', error)
    }
  }

  /**
   * 检测异常行为
   */
  async detectAnomalies(userId: string, ip: string): Promise<boolean> {
    const now = Date.now()
    const oneHourAgo = now - 60 * 60 * 1000

    // 检查登录失败次数
    const failedLogins = await this.redis.zcount(
      `ip_security_events:${ip}`,
      oneHourAgo,
      now
    )

    if (failedLogins > 10) {
      await this.logSecurityEvent({
        type: SecurityEventType.SUSPICIOUS_ACTIVITY,
        userId,
        ip,
        userAgent: '',
        timestamp: new Date(),
        details: { reason: 'Multiple failed login attempts', count: failedLogins },
        severity: 'high',
      })
      return true
    }

    // 检查异常访问模式
    if (userId) {
      const userEvents = await this.redis.zcount(
        `user_security_events:${userId}`,
        oneHourAgo,
        now
      )

      if (userEvents > 1000) { // 1小时内超过1000个事件
        await this.logSecurityEvent({
          type: SecurityEventType.SUSPICIOUS_ACTIVITY,
          userId,
          ip,
          userAgent: '',
          timestamp: new Date(),
          details: { reason: 'High activity volume', count: userEvents },
          severity: 'medium',
        })
        return true
      }
    }

    return false
  }

  /**
   * 获取安全统计
   */
  async getSecurityStats(timeRange: number = 24 * 60 * 60 * 1000): Promise<any> {
    const now = Date.now()
    const startTime = now - timeRange

    const stats = {}

    // 统计各类事件数量
    for (const eventType of Object.values(SecurityEventType)) {
      const count = await this.redis.zcount(
        `security_events:${eventType}`,
        startTime,
        now
      )
      stats[eventType] = count
    }

    // 获取最活跃的IP
    const topIPs = await this.getTopIPs(startTime, now, 10)

    // 获取最活跃的用户
    const topUsers = await this.getTopUsers(startTime, now, 10)

    return {
      eventCounts: stats,
      topIPs,
      topUsers,
      timeRange: timeRange / 1000 / 60 / 60, // 转换为小时
    }
  }

  /**
   * 实时告警检查
   */
  private async checkRealTimeAlerts(event: SecurityEvent): Promise<void> {
    // 关键事件立即告警
    if (event.severity === 'critical') {
      await this.sendAlert('CRITICAL', event)
    }

    // 检查频率告警
    if (event.type === SecurityEventType.LOGIN_FAILURE) {
      const recentFailures = await this.redis.zcount(
        `ip_security_events:${event.ip}`,
        Date.now() - 5 * 60 * 1000, // 5分钟内
        Date.now()
      )

      if (recentFailures >= 5) {
        await this.sendAlert('HIGH_FREQUENCY_FAILURES', event)
      }
    }
  }

  /**
   * 发送告警
   */
  private async sendAlert(alertType: string, event: SecurityEvent): Promise<void> {
    this.logger.warn(`Security Alert: ${alertType}`, {
      event: event.type,
      userId: event.userId,
      ip: event.ip,
      severity: event.severity,
      details: event.details,
    })

    // 这里可以集成邮件、短信、Slack等告警渠道
    // await this.emailService.sendSecurityAlert(alertType, event)
    // await this.slackService.sendSecurityAlert(alertType, event)
  }

  /**
   * 获取最活跃的IP
   */
  private async getTopIPs(startTime: number, endTime: number, limit: number): Promise<any[]> {
    const pattern = 'ip_security_events:*'
    const keys = await this.redis.keys(pattern)

    const ipCounts = []

    for (const key of keys) {
      const ip = key.split(':')[1]
      const count = await this.redis.zcount(key, startTime, endTime)
      if (count > 0) {
        ipCounts.push({ ip, count })
      }
    }

    return ipCounts
      .sort((a, b) => b.count - a.count)
      .slice(0, limit)
  }

  /**
   * 获取最活跃的用户
   */
  private async getTopUsers(startTime: number, endTime: number, limit: number): Promise<any[]> {
    const pattern = 'user_security_events:*'
    const keys = await this.redis.keys(pattern)

    const userCounts = []

    for (const key of keys) {
      const userId = key.split(':')[1]
      const count = await this.redis.zcount(key, startTime, endTime)
      if (count > 0) {
        userCounts.push({ userId, count })
      }
    }

    return userCounts
      .sort((a, b) => b.count - a.count)
      .slice(0, limit)
  }
}
```

---

## 🔐 数据加密和保护

### 敏感数据加密

```typescript
// src/security/encryption/encryption.service.ts
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as crypto from 'crypto'
import * as bcrypt from 'bcrypt'

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm'
  private readonly keyLength = 32
  private readonly ivLength = 16
  private readonly tagLength = 16

  constructor(private readonly configService: ConfigService) {}

  /**
   * 加密敏感数据
   */
  encrypt(text: string, key?: string): string {
    try {
      const encryptionKey = key || this.getEncryptionKey()
      const iv = crypto.randomBytes(this.ivLength)

      const cipher = crypto.createCipher(this.algorithm, encryptionKey)
      cipher.setAAD(Buffer.from('music-app', 'utf8'))

      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')

      const tag = cipher.getAuthTag()

      // 组合IV、tag和加密数据
      const result = iv.toString('hex') + tag.toString('hex') + encrypted

      return Buffer.from(result, 'hex').toString('base64')
    } catch (error) {
      throw new Error('Encryption failed')
    }
  }

  /**
   * 解密敏感数据
   */
  decrypt(encryptedText: string, key?: string): string {
    try {
      const encryptionKey = key || this.getEncryptionKey()
      const buffer = Buffer.from(encryptedText, 'base64')
      const data = buffer.toString('hex')

      // 提取IV、tag和加密数据
      const iv = Buffer.from(data.slice(0, this.ivLength * 2), 'hex')
      const tag = Buffer.from(data.slice(this.ivLength * 2, (this.ivLength + this.tagLength) * 2), 'hex')
      const encrypted = data.slice((this.ivLength + this.tagLength) * 2)

      const decipher = crypto.createDecipher(this.algorithm, encryptionKey)
      decipher.setAAD(Buffer.from('music-app', 'utf8'))
      decipher.setAuthTag(tag)

      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')

      return decrypted
    } catch (error) {
      throw new Error('Decryption failed')
    }
  }

  /**
   * 哈希密码
   */
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12
    return bcrypt.hash(password, saltRounds)
  }

  /**
   * 验证密码
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }

  /**
   * 生成安全的随机字符串
   */
  generateSecureRandom(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex')
  }

  /**
   * 生成哈希
   */
  generateHash(data: string, algorithm: string = 'sha256'): string {
    return crypto.createHash(algorithm).update(data).digest('hex')
  }

  /**
   * HMAC签名
   */
  generateHMAC(data: string, secret?: string): string {
    const hmacSecret = secret || this.getHMACSecret()
    return crypto.createHmac('sha256', hmacSecret).update(data).digest('hex')
  }

  /**
   * 验证HMAC签名
   */
  verifyHMAC(data: string, signature: string, secret?: string): boolean {
    const expectedSignature = this.generateHMAC(data, secret)
    return crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    )
  }

  /**
   * 获取加密密钥
   */
  private getEncryptionKey(): string {
    const key = this.configService.get<string>('ENCRYPTION_KEY')
    if (!key || key.length < this.keyLength) {
      throw new Error('Invalid encryption key')
    }
    return key.slice(0, this.keyLength)
  }

  /**
   * 获取HMAC密钥
   */
  private getHMACSecret(): string {
    const secret = this.configService.get<string>('HMAC_SECRET')
    if (!secret) {
      throw new Error('HMAC secret not configured')
    }
    return secret
  }
}
```

---

## 🧪 安全测试

### 安全测试套件

```typescript
// src/security/testing/security.spec.ts
import { Test, TestingModule } from '@nestjs/testing'
import { EnhancedJwtService } from '../enhanced-jwt.service'
import { EncryptionService } from '../encryption/encryption.service'
import { SecurityMonitorService } from '../monitoring/security-monitor.service'

describe('Security Services', () => {
  let jwtService: EnhancedJwtService
  let encryptionService: EncryptionService
  let monitorService: SecurityMonitorService

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        EnhancedJwtService,
        EncryptionService,
        SecurityMonitorService,
        // Mock providers
      ],
    }).compile()

    jwtService = module.get<EnhancedJwtService>(EnhancedJwtService)
    encryptionService = module.get<EncryptionService>(EncryptionService)
    monitorService = module.get<SecurityMonitorService>(SecurityMonitorService)
  })

  describe('JWT Security', () => {
    it('should generate secure tokens with device fingerprint', async () => {
      const user = { id: 'test-user', username: 'testuser' }
      const deviceInfo = {
        userAgent: 'Mozilla/5.0...',
        ip: '192.168.1.1',
        acceptLanguage: 'en-US',
        timezone: 'UTC',
      }

      const result = await jwtService.generateSecureToken(user, deviceInfo)

      expect(result.accessToken).toBeDefined()
      expect(result.refreshToken).toBeDefined()
      expect(result.fingerprint).toBeDefined()
    })

    it('should reject tokens with mismatched device fingerprint', async () => {
      const user = { id: 'test-user', username: 'testuser' }
      const deviceInfo1 = { userAgent: 'Chrome', ip: '192.168.1.1' }
      const deviceInfo2 = { userAgent: 'Firefox', ip: '192.168.1.2' }

      const { accessToken } = await jwtService.generateSecureToken(user, deviceInfo1)

      await expect(
        jwtService.verifySecureToken(accessToken, deviceInfo2)
      ).rejects.toThrow('Device fingerprint mismatch')
    })
  })

  describe('Encryption', () => {
    it('should encrypt and decrypt data correctly', () => {
      const plaintext = 'sensitive data'

      const encrypted = encryptionService.encrypt(plaintext)
      const decrypted = encryptionService.decrypt(encrypted)

      expect(decrypted).toBe(plaintext)
      expect(encrypted).not.toBe(plaintext)
    })

    it('should hash and verify passwords', async () => {
      const password = 'testpassword123'

      const hash = await encryptionService.hashPassword(password)
      const isValid = await encryptionService.verifyPassword(password, hash)

      expect(isValid).toBe(true)
      expect(hash).not.toBe(password)
    })

    it('should generate and verify HMAC signatures', () => {
      const data = 'test data'

      const signature = encryptionService.generateHMAC(data)
      const isValid = encryptionService.verifyHMAC(data, signature)

      expect(isValid).toBe(true)
    })
  })

  describe('Security Monitoring', () => {
    it('should log security events', async () => {
      const event = {
        type: SecurityEventType.LOGIN_ATTEMPT,
        userId: 'test-user',
        ip: '192.168.1.1',
        userAgent: 'Mozilla/5.0...',
        timestamp: new Date(),
        details: { method: 'password' },
        severity: 'low' as const,
      }

      await expect(
        monitorService.logSecurityEvent(event)
      ).resolves.not.toThrow()
    })

    it('should detect anomalies', async () => {
      const userId = 'test-user'
      const ip = '192.168.1.1'

      // 模拟多次失败登录
      for (let i = 0; i < 15; i++) {
        await monitorService.logSecurityEvent({
          type: SecurityEventType.LOGIN_FAILURE,
          userId,
          ip,
          userAgent: 'Mozilla/5.0...',
          timestamp: new Date(),
          details: { attempt: i + 1 },
          severity: 'medium',
        })
      }

      const hasAnomaly = await monitorService.detectAnomalies(userId, ip)
      expect(hasAnomaly).toBe(true)
    })
  })
})
```

---

## 🔧 安全配置和最佳实践

### 安全配置检查清单

```markdown
## 🔒 安全配置检查清单

### 环境配置
- [ ] 使用强密钥（至少32字符）
- [ ] 启用HTTPS/TLS
- [ ] 配置安全的CORS策略
- [ ] 设置安全的Cookie选项
- [ ] 禁用不必要的HTTP方法

### 认证和授权
- [ ] 实施强密码策略
- [ ] 启用双因素认证
- [ ] 配置JWT安全参数
- [ ] 实施权限最小化原则
- [ ] 定期轮换密钥

### 输入验证
- [ ] 验证所有用户输入
- [ ] 实施SQL注入防护
- [ ] 启用XSS防护
- [ ] 配置CSRF保护
- [ ] 限制文件上传类型和大小

### 监控和日志
- [ ] 启用安全事件日志
- [ ] 配置实时告警
- [ ] 实施异常检测
- [ ] 定期安全审计
- [ ] 备份和恢复测试

### 网络安全
- [ ] 配置防火墙规则
- [ ] 启用DDoS防护
- [ ] 使用安全的DNS
- [ ] 实施网络分段
- [ ] 定期安全扫描
```

### 安全事件响应流程

```typescript
// src/security/incident/incident-response.service.ts
import { Injectable, Logger } from '@nestjs/common'

export enum IncidentSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface SecurityIncident {
  id: string
  type: string
  severity: IncidentSeverity
  description: string
  affectedSystems: string[]
  detectedAt: Date
  status: 'open' | 'investigating' | 'contained' | 'resolved'
  assignedTo?: string
  actions: IncidentAction[]
}

export interface IncidentAction {
  timestamp: Date
  action: string
  performedBy: string
  result: string
}

@Injectable()
export class IncidentResponseService {
  private readonly logger = new Logger(IncidentResponseService.name)

  /**
   * 创建安全事件
   */
  async createIncident(incident: Partial<SecurityIncident>): Promise<SecurityIncident> {
    const newIncident: SecurityIncident = {
      id: this.generateIncidentId(),
      type: incident.type || 'unknown',
      severity: incident.severity || IncidentSeverity.MEDIUM,
      description: incident.description || '',
      affectedSystems: incident.affectedSystems || [],
      detectedAt: new Date(),
      status: 'open',
      actions: [],
    }

    // 根据严重性自动分配
    if (newIncident.severity === IncidentSeverity.CRITICAL) {
      await this.escalateIncident(newIncident)
    }

    this.logger.warn(`Security incident created: ${newIncident.id}`, newIncident)

    return newIncident
  }

  /**
   * 升级事件
   */
  private async escalateIncident(incident: SecurityIncident): Promise<void> {
    // 立即通知安全团队
    await this.notifySecurityTeam(incident)

    // 自动执行紧急响应措施
    await this.executeEmergencyResponse(incident)
  }

  /**
   * 通知安全团队
   */
  private async notifySecurityTeam(incident: SecurityIncident): Promise<void> {
    this.logger.error(`CRITICAL SECURITY INCIDENT: ${incident.id}`, incident)

    // 这里应该集成实际的通知系统
    // await this.emailService.sendCriticalAlert(incident)
    // await this.smsService.sendEmergencyAlert(incident)
    // await this.slackService.sendIncidentAlert(incident)
  }

  /**
   * 执行紧急响应
   */
  private async executeEmergencyResponse(incident: SecurityIncident): Promise<void> {
    // 根据事件类型执行相应的响应措施
    switch (incident.type) {
      case 'brute_force_attack':
        await this.blockSuspiciousIPs(incident)
        break
      case 'data_breach':
        await this.isolateAffectedSystems(incident)
        break
      case 'malware_detected':
        await this.quarantineSystem(incident)
        break
    }
  }

  private async blockSuspiciousIPs(incident: SecurityIncident): Promise<void> {
    // 实施IP阻断逻辑
    this.logger.log(`Blocking suspicious IPs for incident: ${incident.id}`)
  }

  private async isolateAffectedSystems(incident: SecurityIncident): Promise<void> {
    // 隔离受影响的系统
    this.logger.log(`Isolating affected systems for incident: ${incident.id}`)
  }

  private async quarantineSystem(incident: SecurityIncident): Promise<void> {
    // 隔离系统
    this.logger.log(`Quarantining system for incident: ${incident.id}`)
  }

  private generateIncidentId(): string {
    const timestamp = Date.now().toString(36)
    const random = Math.random().toString(36).substr(2, 5)
    return `INC-${timestamp}-${random}`.toUpperCase()
  }
}
```

---

*本文档详细介绍了多层安全防护体系的设计和实现，包括身份认证、权限控制、输入验证、CSRF防护、速率限制、安全监控等核心安全机制。*
```
