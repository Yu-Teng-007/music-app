# 📤 文件上传技术文档

**技术栈**: NestJS + Multer + Sharp + FFmpeg  
**版本**: v1.0  
**更新日期**: 2025-06-27

---

## 📋 文件上传概览

文件上传系统支持音频文件和图片文件的上传处理，包括格式验证、大小限制、文件转换、缩略图生成等功能。系统采用流式处理和异步队列，确保高性能和稳定性。

### 🏗️ 文件上传架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端上传      │    │   上传中间件    │    │   文件处理器    │
│                 │    │                 │    │                 │
│ • 文件选择      │───►│ • 格式验证      │───►│ • 音频转码      │
│ • 进度显示      │    │ • 大小检查      │    │ • 图片压缩      │
│ • 错误处理      │    │ • 临时存储      │    │ • 缩略图生成    │
│ • 断点续传      │    │ • 病毒扫描      │    │ • 元数据提取    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   存储管理      │    │   数据库记录    │    │   CDN分发       │
│                 │    │                 │    │                 │
│ • 本地存储      │    │ • 文件信息      │    │ • 静态资源      │
│ • 云存储       │    │ • 关联关系      │    │ • 缓存策略      │
│ • 备份策略      │    │ • 访问权限      │    │ • 全球加速      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 🔧 服务端配置

### 上传模块配置

```typescript
// src/upload/upload.module.ts
import { Module } from '@nestjs/common'
import { MulterModule } from '@nestjs/platform-express'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { UploadController } from './upload.controller'
import { UploadService } from './upload.service'
import { FileProcessorService } from './file-processor.service'
import { StorageService } from './storage.service'

@Module({
  imports: [
    MulterModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        dest: configService.get<string>('upload.tempDir') || './temp',
        limits: {
          fileSize: configService.get<number>('upload.maxFileSize') || 50 * 1024 * 1024, // 50MB
          files: 5, // 最多5个文件
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [UploadController],
  providers: [UploadService, FileProcessorService, StorageService],
  exports: [UploadService],
})
export class UploadModule {}
```

### 文件上传配置

```typescript
// src/config/upload.config.ts
import { registerAs } from '@nestjs/config'

export default registerAs('upload', () => ({
  // 基础配置
  tempDir: process.env.UPLOAD_TEMP_DIR || './temp',
  uploadDir: process.env.UPLOAD_DIR || './uploads',
  maxFileSize: parseInt(process.env.MAX_FILE_SIZE || '52428800'), // 50MB
  
  // 音频配置
  audio: {
    allowedFormats: ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac'],
    maxDuration: 600, // 10分钟
    outputFormat: 'mp3',
    bitrate: '320k',
  },
  
  // 图片配置
  image: {
    allowedFormats: ['jpg', 'jpeg', 'png', 'webp', 'gif'],
    maxWidth: 2048,
    maxHeight: 2048,
    quality: 85,
    thumbnailSizes: [150, 300, 600],
  },
  
  // 存储配置
  storage: {
    type: process.env.STORAGE_TYPE || 'local', // 'local' | 'aws' | 'aliyun'
    aws: {
      bucket: process.env.AWS_S3_BUCKET,
      region: process.env.AWS_REGION,
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    },
    aliyun: {
      bucket: process.env.ALIYUN_OSS_BUCKET,
      region: process.env.ALIYUN_OSS_REGION,
      accessKeyId: process.env.ALIYUN_ACCESS_KEY_ID,
      accessKeySecret: process.env.ALIYUN_ACCESS_KEY_SECRET,
    },
  },
}))
```

---

## 📁 文件上传控制器

### 上传控制器实现

```typescript
// src/upload/upload.controller.ts
import {
  Controller,
  Post,
  UseInterceptors,
  UploadedFile,
  UploadedFiles,
  Body,
  UseGuards,
  Request,
  BadRequestException,
  PayloadTooLargeException,
} from '@nestjs/common'
import {
  FileInterceptor,
  FilesInterceptor,
  FileFieldsInterceptor,
} from '@nestjs/platform-express'
import {
  ApiTags,
  ApiOperation,
  ApiConsumes,
  ApiBody,
  ApiBearerAuth,
  ApiResponse,
} from '@nestjs/swagger'
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard'
import { UploadService } from './upload.service'
import { FileValidationPipe } from './pipes/file-validation.pipe'
import { UploadAudioDto, UploadImageDto } from './dto/upload.dto'

@ApiTags('upload')
@Controller('upload')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth('JWT-auth')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post('audio')
  @ApiOperation({ summary: '上传音频文件' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    description: '音频文件上传',
    type: UploadAudioDto,
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadAudio(
    @UploadedFile(new FileValidationPipe('audio')) file: Express.Multer.File,
    @Body() uploadAudioDto: UploadAudioDto,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processAudioFile(
        file,
        uploadAudioDto,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: '音频文件上传成功',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('image')
  @ApiOperation({ summary: '上传图片文件' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    description: '图片文件上传',
    type: UploadImageDto,
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadImage(
    @UploadedFile(new FileValidationPipe('image')) file: Express.Multer.File,
    @Body() uploadImageDto: UploadImageDto,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processImageFile(
        file,
        uploadImageDto,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: '图片文件上传成功',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('multiple')
  @ApiOperation({ summary: '批量上传文件' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FilesInterceptor('files', 10)) // 最多10个文件
  async uploadMultiple(
    @UploadedFiles(new FileValidationPipe('mixed')) files: Express.Multer.File[],
    @Request() req: any,
  ) {
    try {
      const results = await this.uploadService.processMultipleFiles(
        files,
        req.user.id,
      )
      
      return {
        success: true,
        data: results,
        message: `成功上传 ${results.length} 个文件`,
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('avatar')
  @ApiOperation({ summary: '上传用户头像' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FileInterceptor('avatar'))
  async uploadAvatar(
    @UploadedFile(new FileValidationPipe('avatar')) file: Express.Multer.File,
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processAvatarFile(
        file,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: '头像上传成功',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }

  @Post('cover')
  @ApiOperation({ summary: '上传封面图片' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FileInterceptor('cover'))
  async uploadCover(
    @UploadedFile(new FileValidationPipe('cover')) file: Express.Multer.File,
    @Body() body: { type: 'song' | 'playlist' | 'album' },
    @Request() req: any,
  ) {
    try {
      const result = await this.uploadService.processCoverFile(
        file,
        body.type,
        req.user.id,
      )
      
      return {
        success: true,
        data: result,
        message: '封面图片上传成功',
      }
    } catch (error) {
      throw new BadRequestException(error.message)
    }
  }
}
```

---

## 🎵 文件处理器服务

### 音频处理实现

```typescript
// src/upload/file-processor.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as ffmpeg from 'fluent-ffmpeg'
import * as sharp from 'sharp'
import * as path from 'path'
import * as fs from 'fs/promises'
import { promisify } from 'util'

@Injectable()
export class FileProcessorService {
  private readonly logger = new Logger(FileProcessorService.name)

  constructor(private readonly configService: ConfigService) {}

  /**
   * 提取音频元数据
   */
  async extractAudioMetadata(filePath: string): Promise<any> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(filePath, (err, metadata) => {
        if (err) {
          this.logger.error('Failed to extract audio metadata:', err)
          reject(new Error('无法读取音频文件信息'))
          return
        }

        const format = metadata.format
        const audioStream = metadata.streams.find(s => s.codec_type === 'audio')

        resolve({
          duration: format.duration,
          bitrate: format.bit_rate,
          size: format.size,
          title: format.tags?.title,
          artist: format.tags?.artist,
          album: format.tags?.album,
          genre: format.tags?.genre,
          year: format.tags?.date ? parseInt(format.tags.date) : null,
          codec: audioStream?.codec_name,
          sampleRate: audioStream?.sample_rate,
          channels: audioStream?.channels,
        })
      })
    })
  }

  /**
   * 转换音频格式
   */
  async convertAudio(inputPath: string, outputFormat: string): Promise<{
    path: string
    size: number
  }> {
    const outputPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_converted.${outputFormat}`
    )

    const bitrate = this.configService.get<string>('upload.audio.bitrate')

    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .audioCodec('libmp3lame')
        .audioBitrate(bitrate)
        .format(outputFormat)
        .output(outputPath)
        .on('end', async () => {
          try {
            const stats = await fs.stat(outputPath)
            resolve({
              path: outputPath,
              size: stats.size,
            })
          } catch (error) {
            reject(error)
          }
        })
        .on('error', (err) => {
          this.logger.error('Audio conversion failed:', err)
          reject(new Error('音频转换失败'))
        })
        .run()
    })
  }

  /**
   * 提取或生成封面图片
   */
  async extractOrGenerateCover(audioPath: string, metadata: any): Promise<string> {
    const coverPath = path.join(
      path.dirname(audioPath),
      `${path.parse(audioPath).name}_cover.jpg`
    )

    try {
      // 尝试从音频文件中提取封面
      await this.extractCoverFromAudio(audioPath, coverPath)
      return coverPath
    } catch (error) {
      // 如果提取失败，生成默认封面
      return this.generateDefaultCover(coverPath, metadata)
    }
  }

  /**
   * 从音频文件提取封面
   */
  private async extractCoverFromAudio(audioPath: string, outputPath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      ffmpeg(audioPath)
        .outputOptions(['-an', '-vcodec', 'copy'])
        .output(outputPath)
        .on('end', () => resolve())
        .on('error', (err) => reject(err))
        .run()
    })
  }

  /**
   * 生成默认封面
   */
  private async generateDefaultCover(outputPath: string, metadata: any): Promise<string> {
    const width = 600
    const height = 600

    // 创建一个简单的默认封面
    await sharp({
      create: {
        width,
        height,
        channels: 3,
        background: { r: 100, g: 100, b: 100 }
      }
    })
    .jpeg({ quality: 90 })
    .toFile(outputPath)

    return outputPath
  }

  /**
   * 处理图片文件
   */
  async processImage(
    inputPath: string,
    type: 'avatar' | 'cover' | 'general'
  ): Promise<Array<{ path: string; size?: number }>> {
    const results = []
    const maxWidth = this.configService.get<number>('upload.image.maxWidth')
    const maxHeight = this.configService.get<number>('upload.image.maxHeight')
    const quality = this.configService.get<number>('upload.image.quality')

    // 处理原图
    const originalPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_processed.jpg`
    )

    await sharp(inputPath)
      .resize(maxWidth, maxHeight, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality })
      .toFile(originalPath)

    results.push({ path: originalPath })

    // 根据类型生成缩略图
    if (type === 'avatar') {
      const sizes = [150, 300]
      for (const size of sizes) {
        const thumbnailPath = path.join(
          path.dirname(inputPath),
          `${path.parse(inputPath).name}_${size}x${size}.jpg`
        )

        await sharp(inputPath)
          .resize(size, size, { fit: 'cover' })
          .jpeg({ quality: 80 })
          .toFile(thumbnailPath)

        results.push({ path: thumbnailPath, size })
      }
    } else if (type === 'cover') {
      const sizes = [300, 600]
      for (const size of sizes) {
        const thumbnailPath = path.join(
          path.dirname(inputPath),
          `${path.parse(inputPath).name}_${size}x${size}.jpg`
        )

        await sharp(inputPath)
          .resize(size, size, { fit: 'cover' })
          .jpeg({ quality: 85 })
          .toFile(thumbnailPath)

        results.push({ path: thumbnailPath, size })
      }
    }

    return results
  }

  /**
   * 生成图片缩略图
   */
  async generateThumbnails(
    inputPath: string,
    sizes: number[]
  ): Promise<Array<{ path: string; size: number }>> {
    const results = []

    for (const size of sizes) {
      const thumbnailPath = path.join(
        path.dirname(inputPath),
        `${path.parse(inputPath).name}_thumb_${size}.jpg`
      )

      await sharp(inputPath)
        .resize(size, size, {
          fit: 'cover',
          position: 'center'
        })
        .jpeg({ quality: 80 })
        .toFile(thumbnailPath)

      results.push({ path: thumbnailPath, size })
    }

    return results
  }

  /**
   * 压缩图片
   */
  async compressImage(
    inputPath: string,
    quality: number = 85
  ): Promise<{ path: string; originalSize: number; compressedSize: number }> {
    const outputPath = path.join(
      path.dirname(inputPath),
      `${path.parse(inputPath).name}_compressed.jpg`
    )

    const originalStats = await fs.stat(inputPath)

    await sharp(inputPath)
      .jpeg({ quality, progressive: true })
      .toFile(outputPath)

    const compressedStats = await fs.stat(outputPath)

    return {
      path: outputPath,
      originalSize: originalStats.size,
      compressedSize: compressedStats.size,
    }
  }

  /**
   * 获取图片信息
   */
  async getImageInfo(filePath: string): Promise<{
    width: number
    height: number
    format: string
    size: number
  }> {
    const metadata = await sharp(filePath).metadata()
    const stats = await fs.stat(filePath)

    return {
      width: metadata.width,
      height: metadata.height,
      format: metadata.format,
      size: stats.size,
    }
  }

  /**
   * 验证音频文件完整性
   */
  async validateAudioFile(filePath: string): Promise<boolean> {
    try {
      const metadata = await this.extractAudioMetadata(filePath)
      return metadata.duration > 0
    } catch (error) {
      return false
    }
  }

  /**
   * 验证图片文件完整性
   */
  async validateImageFile(filePath: string): Promise<boolean> {
    try {
      const metadata = await sharp(filePath).metadata()
      return metadata.width > 0 && metadata.height > 0
    } catch (error) {
      return false
    }
  }
}
```

---

## 💾 存储服务

### 多存储后端支持

```typescript
// src/upload/storage.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as path from 'path'
import * as fs from 'fs/promises'
import { v4 as uuidv4 } from 'uuid'

interface StorageProvider {
  uploadFile(filePath: string, category: string): Promise<string>
  deleteFile(fileUrl: string): Promise<void>
  getFileUrl(key: string): string
}

@Injectable()
export class StorageService {
  private readonly logger = new Logger(StorageService.name)
  private provider: StorageProvider

  constructor(private readonly configService: ConfigService) {
    this.initializeProvider()
  }

  private initializeProvider() {
    const storageType = this.configService.get<string>('upload.storage.type')

    switch (storageType) {
      case 'aws':
        this.provider = new AWSStorageProvider(this.configService)
        break
      case 'aliyun':
        this.provider = new AliyunStorageProvider(this.configService)
        break
      default:
        this.provider = new LocalStorageProvider(this.configService)
    }

    this.logger.log(`Initialized ${storageType} storage provider`)
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    return this.provider.uploadFile(filePath, category)
  }

  async deleteFile(fileUrl: string): Promise<void> {
    return this.provider.deleteFile(fileUrl)
  }

  getFileUrl(key: string): string {
    return this.provider.getFileUrl(key)
  }
}

/**
 * 本地存储提供者
 */
class LocalStorageProvider implements StorageProvider {
  private readonly uploadDir: string

  constructor(private readonly configService: ConfigService) {
    this.uploadDir = this.configService.get<string>('upload.uploadDir')
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    const fileName = `${uuidv4()}${path.extname(filePath)}`
    const categoryDir = path.join(this.uploadDir, category)
    const targetPath = path.join(categoryDir, fileName)

    // 确保目录存在
    await fs.mkdir(categoryDir, { recursive: true })

    // 复制文件
    await fs.copyFile(filePath, targetPath)

    // 返回相对URL
    return `/uploads/${category}/${fileName}`
  }

  async deleteFile(fileUrl: string): Promise<void> {
    const filePath = path.join(process.cwd(), 'public', fileUrl)
    try {
      await fs.unlink(filePath)
    } catch (error) {
      // 文件可能已经不存在，忽略错误
    }
  }

  getFileUrl(key: string): string {
    return key // 本地存储直接返回相对路径
  }
}

/**
 * AWS S3存储提供者
 */
class AWSStorageProvider implements StorageProvider {
  private s3Client: any

  constructor(private readonly configService: ConfigService) {
    // 这里应该初始化AWS S3客户端
    // const AWS = require('aws-sdk')
    // this.s3Client = new AWS.S3({...})
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    // AWS S3上传实现
    throw new Error('AWS S3 provider not implemented')
  }

  async deleteFile(fileUrl: string): Promise<void> {
    // AWS S3删除实现
    throw new Error('AWS S3 provider not implemented')
  }

  getFileUrl(key: string): string {
    // 返回S3 URL
    return key
  }
}

/**
 * 阿里云OSS存储提供者
 */
class AliyunStorageProvider implements StorageProvider {
  private ossClient: any

  constructor(private readonly configService: ConfigService) {
    // 这里应该初始化阿里云OSS客户端
    // const OSS = require('ali-oss')
    // this.ossClient = new OSS({...})
  }

  async uploadFile(filePath: string, category: string): Promise<string> {
    // 阿里云OSS上传实现
    throw new Error('Aliyun OSS provider not implemented')
  }

  async deleteFile(fileUrl: string): Promise<void> {
    // 阿里云OSS删除实现
    throw new Error('Aliyun OSS provider not implemented')
  }

  getFileUrl(key: string): string {
    // 返回OSS URL
    return key
  }
}
```

---

## 🔍 文件验证管道

### 文件验证实现

```typescript
// src/upload/pipes/file-validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as path from 'path'
import * as fileType from 'file-type'
import * as fs from 'fs'

@Injectable()
export class FileValidationPipe implements PipeTransform {
  constructor(
    private readonly fileCategory: 'audio' | 'image' | 'avatar' | 'cover' | 'mixed',
    private readonly configService?: ConfigService,
  ) {}

  async transform(value: Express.Multer.File | Express.Multer.File[], metadata: ArgumentMetadata) {
    if (!value) {
      throw new BadRequestException('文件不能为空')
    }

    const files = Array.isArray(value) ? value : [value]

    for (const file of files) {
      await this.validateFile(file)
    }

    return value
  }

  private async validateFile(file: Express.Multer.File) {
    // 1. 检查文件是否存在
    if (!file || !file.path) {
      throw new BadRequestException('文件上传失败')
    }

    // 2. 检查文件大小
    this.validateFileSize(file)

    // 3. 检查文件扩展名
    this.validateFileExtension(file)

    // 4. 检查文件MIME类型
    await this.validateFileMimeType(file)

    // 5. 检查文件内容（魔数验证）
    await this.validateFileContent(file)
  }

  private validateFileSize(file: Express.Multer.File) {
    const maxSize = this.getMaxFileSize()

    if (file.size > maxSize) {
      throw new BadRequestException(
        `文件大小超过限制，最大允许 ${Math.round(maxSize / 1024 / 1024)}MB`
      )
    }

    if (file.size === 0) {
      throw new BadRequestException('文件内容为空')
    }
  }

  private validateFileExtension(file: Express.Multer.File) {
    const allowedExtensions = this.getAllowedExtensions()
    const fileExtension = path.extname(file.originalname).toLowerCase().slice(1)

    if (!allowedExtensions.includes(fileExtension)) {
      throw new BadRequestException(
        `不支持的文件格式 .${fileExtension}，支持的格式: ${allowedExtensions.join(', ')}`
      )
    }
  }

  private async validateFileMimeType(file: Express.Multer.File) {
    const allowedMimeTypes = this.getAllowedMimeTypes()

    if (!allowedMimeTypes.includes(file.mimetype)) {
      throw new BadRequestException(
        `不支持的文件类型 ${file.mimetype}`
      )
    }
  }

  private async validateFileContent(file: Express.Multer.File) {
    try {
      // 读取文件头部字节来验证文件类型
      const buffer = fs.readFileSync(file.path)
      const detectedType = await fileType.fromBuffer(buffer)

      if (!detectedType) {
        throw new BadRequestException('无法识别的文件类型')
      }

      const allowedMimeTypes = this.getAllowedMimeTypes()

      if (!allowedMimeTypes.includes(detectedType.mime)) {
        throw new BadRequestException(
          `文件内容与扩展名不匹配，检测到的类型: ${detectedType.mime}`
        )
      }
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error
      }
      throw new BadRequestException('文件验证失败')
    }
  }

  private getMaxFileSize(): number {
    switch (this.fileCategory) {
      case 'avatar':
        return 5 * 1024 * 1024 // 5MB
      case 'cover':
        return 10 * 1024 * 1024 // 10MB
      case 'audio':
        return 50 * 1024 * 1024 // 50MB
      case 'image':
        return 20 * 1024 * 1024 // 20MB
      default:
        return 50 * 1024 * 1024 // 50MB
    }
  }

  private getAllowedExtensions(): string[] {
    switch (this.fileCategory) {
      case 'audio':
        return ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac']
      case 'image':
      case 'avatar':
      case 'cover':
        return ['jpg', 'jpeg', 'png', 'webp']
      case 'mixed':
        return ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac', 'jpg', 'jpeg', 'png', 'webp']
      default:
        return []
    }
  }

  private getAllowedMimeTypes(): string[] {
    switch (this.fileCategory) {
      case 'audio':
        return [
          'audio/mpeg',
          'audio/wav',
          'audio/flac',
          'audio/ogg',
          'audio/mp4',
          'audio/aac',
        ]
      case 'image':
      case 'avatar':
      case 'cover':
        return [
          'image/jpeg',
          'image/png',
          'image/webp',
        ]
      case 'mixed':
        return [
          'audio/mpeg',
          'audio/wav',
          'audio/flac',
          'audio/ogg',
          'audio/mp4',
          'audio/aac',
          'image/jpeg',
          'image/png',
          'image/webp',
        ]
      default:
        return []
    }
  }
}
```

---

## 📱 前端上传组件

### Vue 3上传组件

```vue
<!-- src/components/FileUpload.vue -->
<template>
  <div class="file-upload">
    <!-- 拖拽上传区域 -->
    <div
      class="upload-area"
      :class="{
        'drag-over': isDragOver,
        'uploading': isUploading,
        'error': hasError
      }"
      @drop="handleDrop"
      @dragover="handleDragOver"
      @dragleave="handleDragLeave"
      @click="triggerFileInput"
    >
      <input
        ref="fileInput"
        type="file"
        :multiple="multiple"
        :accept="acceptTypes"
        @change="handleFileSelect"
        style="display: none"
      />

      <div class="upload-content">
        <div v-if="!isUploading" class="upload-icon">
          <UploadIcon size="48" />
        </div>
        <div v-else class="upload-progress">
          <div class="progress-circle">
            <svg viewBox="0 0 36 36" class="circular-chart">
              <path
                class="circle-bg"
                d="M18 2.0845
                  a 15.9155 15.9155 0 0 1 0 31.831
                  a 15.9155 15.9155 0 0 1 0 -31.831"
              />
              <path
                class="circle"
                :stroke-dasharray="`${uploadProgress}, 100`"
                d="M18 2.0845
                  a 15.9155 15.9155 0 0 1 0 31.831
                  a 15.9155 15.9155 0 0 1 0 -31.831"
              />
            </svg>
            <div class="progress-text">{{ Math.round(uploadProgress) }}%</div>
          </div>
        </div>

        <div class="upload-text">
          <h3 v-if="!isUploading">
            {{ isDragOver ? '释放文件开始上传' : '点击或拖拽文件到此处' }}
          </h3>
          <h3 v-else>正在上传...</h3>
          <p>支持格式: {{ acceptTypesText }}</p>
          <p>最大大小: {{ maxSizeText }}</p>
        </div>
      </div>
    </div>

    <!-- 文件列表 -->
    <div v-if="files.length > 0" class="file-list">
      <h4>已选择的文件</h4>
      <div
        v-for="(file, index) in files"
        :key="index"
        class="file-item"
        :class="{ 'upload-success': file.uploaded, 'upload-error': file.error }"
      >
        <div class="file-info">
          <div class="file-icon">
            <FileIcon v-if="isAudioFile(file)" />
            <ImageIcon v-else />
          </div>
          <div class="file-details">
            <div class="file-name">{{ file.name }}</div>
            <div class="file-size">{{ formatFileSize(file.size) }}</div>
            <div v-if="file.error" class="file-error">{{ file.error }}</div>
          </div>
        </div>
        <div class="file-actions">
          <button
            v-if="!file.uploaded && !file.uploading"
            @click="removeFile(index)"
            class="remove-btn"
          >
            <XIcon size="16" />
          </button>
          <div v-if="file.uploading" class="file-progress">
            <div class="progress-bar">
              <div
                class="progress-fill"
                :style="{ width: `${file.progress || 0}%` }"
              ></div>
            </div>
          </div>
          <div v-if="file.uploaded" class="success-icon">
            <CheckIcon size="16" />
          </div>
        </div>
      </div>
    </div>

    <!-- 上传按钮 -->
    <div v-if="files.length > 0 && !isUploading" class="upload-actions">
      <button @click="startUpload" class="upload-btn" :disabled="isUploading">
        开始上传
      </button>
      <button @click="clearFiles" class="clear-btn">
        清空列表
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineEmits, defineProps } from 'vue'
import { UploadIcon, FileIcon, ImageIcon, XIcon, CheckIcon } from 'lucide-vue-next'
import { uploadApi } from '@/services/upload-api'

interface FileItem {
  file: File
  name: string
  size: number
  type: string
  uploading?: boolean
  uploaded?: boolean
  progress?: number
  error?: string
  result?: any
}

const props = defineProps<{
  uploadType: 'audio' | 'image' | 'mixed'
  multiple?: boolean
  maxSize?: number // MB
}>()

const emit = defineEmits<{
  success: [files: any[]]
  error: [error: string]
  progress: [progress: number]
}>()

// 响应式数据
const fileInput = ref<HTMLInputElement>()
const files = ref<FileItem[]>([])
const isDragOver = ref(false)
const isUploading = ref(false)
const uploadProgress = ref(0)
const hasError = ref(false)

// 计算属性
const acceptTypes = computed(() => {
  switch (props.uploadType) {
    case 'audio':
      return '.mp3,.wav,.flac,.ogg,.m4a,.aac'
    case 'image':
      return '.jpg,.jpeg,.png,.webp'
    case 'mixed':
      return '.mp3,.wav,.flac,.ogg,.m4a,.aac,.jpg,.jpeg,.png,.webp'
    default:
      return '*'
  }
})

const acceptTypesText = computed(() => {
  switch (props.uploadType) {
    case 'audio':
      return 'MP3, WAV, FLAC, OGG, M4A, AAC'
    case 'image':
      return 'JPG, PNG, WebP'
    case 'mixed':
      return '音频和图片文件'
    default:
      return '所有文件'
  }
})

const maxSizeText = computed(() => {
  const maxSize = props.maxSize || 50
  return `${maxSize}MB`
})

// 方法
const triggerFileInput = () => {
  if (!isUploading.value) {
    fileInput.value?.click()
  }
}

const handleFileSelect = (event: Event) => {
  const target = event.target as HTMLInputElement
  if (target.files) {
    addFiles(Array.from(target.files))
  }
}

const handleDrop = (event: DragEvent) => {
  event.preventDefault()
  isDragOver.value = false

  if (event.dataTransfer?.files) {
    addFiles(Array.from(event.dataTransfer.files))
  }
}

const handleDragOver = (event: DragEvent) => {
  event.preventDefault()
  isDragOver.value = true
}

const handleDragLeave = () => {
  isDragOver.value = false
}

const addFiles = (newFiles: File[]) => {
  const validFiles = newFiles.filter(file => validateFile(file))

  const fileItems: FileItem[] = validFiles.map(file => ({
    file,
    name: file.name,
    size: file.size,
    type: file.type,
  }))

  if (props.multiple) {
    files.value.push(...fileItems)
  } else {
    files.value = fileItems.slice(0, 1)
  }
}

const validateFile = (file: File): boolean => {
  const maxSize = (props.maxSize || 50) * 1024 * 1024

  if (file.size > maxSize) {
    hasError.value = true
    emit('error', `文件 ${file.name} 大小超过限制`)
    return false
  }

  return true
}

const removeFile = (index: number) => {
  files.value.splice(index, 1)
}

const clearFiles = () => {
  files.value = []
  hasError.value = false
}

const startUpload = async () => {
  if (files.value.length === 0) return

  isUploading.value = true
  uploadProgress.value = 0

  const results = []
  const totalFiles = files.value.length

  for (let i = 0; i < files.value.length; i++) {
    const fileItem = files.value[i]
    fileItem.uploading = true

    try {
      const result = await uploadFile(fileItem)
      fileItem.uploaded = true
      fileItem.result = result
      results.push(result)
    } catch (error) {
      fileItem.error = error.message
      hasError.value = true
    } finally {
      fileItem.uploading = false
      uploadProgress.value = ((i + 1) / totalFiles) * 100
      emit('progress', uploadProgress.value)
    }
  }

  isUploading.value = false

  if (results.length > 0) {
    emit('success', results)
  }
}

const uploadFile = async (fileItem: FileItem) => {
  const formData = new FormData()
  formData.append('file', fileItem.file)

  const onProgress = (progress: number) => {
    fileItem.progress = progress
  }

  switch (props.uploadType) {
    case 'audio':
      return uploadApi.uploadAudio(formData, onProgress)
    case 'image':
      return uploadApi.uploadImage(formData, onProgress)
    default:
      return uploadApi.uploadFile(formData, onProgress)
  }
}

const isAudioFile = (fileItem: FileItem): boolean => {
  return fileItem.type.startsWith('audio/')
}

const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}
</script>

<style scoped>
.file-upload {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.upload-area {
  border: 2px dashed #d1d5db;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #f9fafb;
}

.upload-area:hover {
  border-color: #3b82f6;
  background-color: #eff6ff;
}

.upload-area.drag-over {
  border-color: #3b82f6;
  background-color: #dbeafe;
}

.upload-area.uploading {
  cursor: not-allowed;
  opacity: 0.7;
}

.upload-area.error {
  border-color: #ef4444;
  background-color: #fef2f2;
}

.upload-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.upload-icon {
  color: #6b7280;
}

.progress-circle {
  position: relative;
  width: 60px;
  height: 60px;
}

.circular-chart {
  width: 100%;
  height: 100%;
}

.circle-bg {
  fill: none;
  stroke: #e5e7eb;
  stroke-width: 2;
}

.circle {
  fill: none;
  stroke: #3b82f6;
  stroke-width: 2;
  stroke-linecap: round;
  transition: stroke-dasharray 0.3s ease;
}

.progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.875rem;
  font-weight: 600;
  color: #3b82f6;
}

.file-list {
  margin-top: 1.5rem;
}

.file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  margin-bottom: 0.5rem;
  background-color: white;
}

.file-item.upload-success {
  border-color: #10b981;
  background-color: #f0fdf4;
}

.file-item.upload-error {
  border-color: #ef4444;
  background-color: #fef2f2;
}

.file-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.file-icon {
  color: #6b7280;
}

.file-details {
  flex: 1;
}

.file-name {
  font-weight: 500;
  color: #111827;
}

.file-size {
  font-size: 0.875rem;
  color: #6b7280;
}

.file-error {
  font-size: 0.875rem;
  color: #ef4444;
}

.file-actions {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.remove-btn {
  padding: 0.25rem;
  border: none;
  background: none;
  color: #6b7280;
  cursor: pointer;
  border-radius: 4px;
}

.remove-btn:hover {
  color: #ef4444;
  background-color: #fef2f2;
}

.progress-bar {
  width: 100px;
  height: 4px;
  background-color: #e5e7eb;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background-color: #3b82f6;
  transition: width 0.3s ease;
}

.success-icon {
  color: #10b981;
}

.upload-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

.upload-btn {
  flex: 1;
  padding: 0.75rem 1.5rem;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.upload-btn:hover:not(:disabled) {
  background-color: #2563eb;
}

.upload-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.clear-btn {
  padding: 0.75rem 1.5rem;
  background-color: #f3f4f6;
  color: #374151;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.clear-btn:hover {
  background-color: #e5e7eb;
}
</style>
```

---

*本文档详细介绍了文件上传系统的完整实现，包括服务端处理、文件验证、存储管理和前端组件。*
```
```

---

## 🛠️ 文件处理服务

### 核心上传服务

```typescript
// src/upload/upload.service.ts
import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { Song } from '../entities/song.entity'
import { FileProcessorService } from './file-processor.service'
import { StorageService } from './storage.service'
import { UploadAudioDto, UploadImageDto } from './dto/upload.dto'
import * as path from 'path'
import * as fs from 'fs/promises'

@Injectable()
export class UploadService {
  private readonly logger = new Logger(UploadService.name)

  constructor(
    @InjectRepository(Song)
    private readonly songRepository: Repository<Song>,
    private readonly configService: ConfigService,
    private readonly fileProcessor: FileProcessorService,
    private readonly storageService: StorageService,
  ) {}

  /**
   * 处理音频文件上传
   */
  async processAudioFile(
    file: Express.Multer.File,
    uploadDto: UploadAudioDto,
    userId: string,
  ) {
    this.logger.log(`Processing audio file: ${file.originalname}`)

    try {
      // 1. 验证文件格式和大小
      await this.validateAudioFile(file)

      // 2. 提取音频元数据
      const metadata = await this.fileProcessor.extractAudioMetadata(file.path)

      // 3. 转换音频格式（如果需要）
      const processedFile = await this.fileProcessor.convertAudio(
        file.path,
        this.configService.get('upload.audio.outputFormat'),
      )

      // 4. 生成缩略图（从音频文件中提取或使用默认）
      const coverPath = await this.fileProcessor.extractOrGenerateCover(
        processedFile.path,
        metadata,
      )

      // 5. 上传到存储服务
      const [audioUrl, coverUrl] = await Promise.all([
        this.storageService.uploadFile(processedFile.path, 'audio'),
        this.storageService.uploadFile(coverPath, 'images'),
      ])

      // 6. 保存到数据库
      const song = this.songRepository.create({
        title: uploadDto.title || metadata.title || path.parse(file.originalname).name,
        artist: uploadDto.artist || metadata.artist || 'Unknown Artist',
        album: uploadDto.album || metadata.album || 'Unknown Album',
        genre: uploadDto.genre || metadata.genre,
        year: uploadDto.year || metadata.year,
        duration: Math.round(metadata.duration),
        audioUrl,
        coverUrl,
        fileSize: processedFile.size,
        originalFileName: file.originalname,
        lyrics: uploadDto.lyrics,
      })

      const savedSong = await this.songRepository.save(song)

      // 7. 清理临时文件
      await this.cleanupTempFiles([file.path, processedFile.path, coverPath])

      this.logger.log(`Audio file processed successfully: ${savedSong.id}`)

      return {
        id: savedSong.id,
        title: savedSong.title,
        artist: savedSong.artist,
        duration: savedSong.duration,
        audioUrl: savedSong.audioUrl,
        coverUrl: savedSong.coverUrl,
        fileSize: savedSong.fileSize,
      }
    } catch (error) {
      // 清理临时文件
      await this.cleanupTempFiles([file.path])
      throw error
    }
  }

  /**
   * 处理图片文件上传
   */
  async processImageFile(
    file: Express.Multer.File,
    uploadDto: UploadImageDto,
    userId: string,
  ) {
    this.logger.log(`Processing image file: ${file.originalname}`)

    try {
      // 1. 验证图片文件
      await this.validateImageFile(file)

      // 2. 处理图片（压缩、调整大小）
      const processedImages = await this.fileProcessor.processImage(
        file.path,
        uploadDto.type || 'general',
      )

      // 3. 上传到存储服务
      const uploadPromises = processedImages.map(img =>
        this.storageService.uploadFile(img.path, 'images')
      )
      const urls = await Promise.all(uploadPromises)

      // 4. 构建返回结果
      const result = {
        original: urls[0],
        thumbnails: {},
      }

      processedImages.forEach((img, index) => {
        if (img.size) {
          result.thumbnails[`${img.size}x${img.size}`] = urls[index]
        }
      })

      // 5. 清理临时文件
      const tempFiles = [file.path, ...processedImages.map(img => img.path)]
      await this.cleanupTempFiles(tempFiles)

      this.logger.log(`Image file processed successfully`)

      return result
    } catch (error) {
      await this.cleanupTempFiles([file.path])
      throw error
    }
  }

  /**
   * 处理头像上传
   */
  async processAvatarFile(file: Express.Multer.File, userId: string) {
    const uploadDto: UploadImageDto = { type: 'avatar' }
    return this.processImageFile(file, uploadDto, userId)
  }

  /**
   * 处理封面图片上传
   */
  async processCoverFile(
    file: Express.Multer.File,
    type: 'song' | 'playlist' | 'album',
    userId: string,
  ) {
    const uploadDto: UploadImageDto = { type: 'cover' }
    return this.processImageFile(file, uploadDto, userId)
  }

  /**
   * 批量处理文件
   */
  async processMultipleFiles(files: Express.Multer.File[], userId: string) {
    const results = []

    for (const file of files) {
      try {
        if (this.isAudioFile(file)) {
          const result = await this.processAudioFile(
            file,
            { title: path.parse(file.originalname).name },
            userId,
          )
          results.push({ type: 'audio', ...result })
        } else if (this.isImageFile(file)) {
          const result = await this.processImageFile(
            file,
            { type: 'general' },
            userId,
          )
          results.push({ type: 'image', ...result })
        }
      } catch (error) {
        this.logger.error(`Failed to process file ${file.originalname}:`, error)
        results.push({
          type: 'error',
          filename: file.originalname,
          error: error.message,
        })
      }
    }

    return results
  }

  /**
   * 验证音频文件
   */
  private async validateAudioFile(file: Express.Multer.File) {
    const allowedFormats = this.configService.get<string[]>('upload.audio.allowedFormats')
    const maxSize = this.configService.get<number>('upload.maxFileSize')

    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    
    if (!allowedFormats.includes(ext)) {
      throw new Error(`不支持的音频格式: ${ext}`)
    }

    if (file.size > maxSize) {
      throw new Error(`文件大小超过限制: ${Math.round(file.size / 1024 / 1024)}MB`)
    }
  }

  /**
   * 验证图片文件
   */
  private async validateImageFile(file: Express.Multer.File) {
    const allowedFormats = this.configService.get<string[]>('upload.image.allowedFormats')
    const maxSize = this.configService.get<number>('upload.maxFileSize')

    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    
    if (!allowedFormats.includes(ext)) {
      throw new Error(`不支持的图片格式: ${ext}`)
    }

    if (file.size > maxSize) {
      throw new Error(`文件大小超过限制: ${Math.round(file.size / 1024 / 1024)}MB`)
    }
  }

  /**
   * 判断是否为音频文件
   */
  private isAudioFile(file: Express.Multer.File): boolean {
    const audioFormats = this.configService.get<string[]>('upload.audio.allowedFormats')
    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    return audioFormats.includes(ext)
  }

  /**
   * 判断是否为图片文件
   */
  private isImageFile(file: Express.Multer.File): boolean {
    const imageFormats = this.configService.get<string[]>('upload.image.allowedFormats')
    const ext = path.extname(file.originalname).toLowerCase().slice(1)
    return imageFormats.includes(ext)
  }

  /**
   * 清理临时文件
   */
  private async cleanupTempFiles(filePaths: string[]) {
    for (const filePath of filePaths) {
      try {
        await fs.unlink(filePath)
      } catch (error) {
        this.logger.warn(`Failed to cleanup temp file: ${filePath}`)
      }
    }
  }
}
```
